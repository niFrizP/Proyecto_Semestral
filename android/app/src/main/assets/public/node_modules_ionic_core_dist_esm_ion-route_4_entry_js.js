"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["node_modules_ionic_core_dist_esm_ion-route_4_entry_js"],{

/***/ 5534:
/*!****************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/ion-route_4.entry.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ion_route": () => (/* binding */ Route),
/* harmony export */   "ion_route_redirect": () => (/* binding */ RouteRedirect),
/* harmony export */   "ion_router": () => (/* binding */ Router),
/* harmony export */   "ion_router_link": () => (/* binding */ RouterLink)
/* harmony export */ });
/* harmony import */ var C_proyecto_Ionic_Proyecto_semestral_proyecto_semestral_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 1670);
/* harmony import */ var _index_1a99aeb7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-1a99aeb7.js */ 4895);
/* harmony import */ var _helpers_4d272360_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers-4d272360.js */ 9158);
/* harmony import */ var _ionic_global_04e268e7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ionic-global-04e268e7.js */ 2107);
/* harmony import */ var _theme_7670341c_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./theme-7670341c.js */ 320);


/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */




const Route = class {
  constructor(hostRef) {
    (0,_index_1a99aeb7_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
    this.ionRouteDataChanged = (0,_index_1a99aeb7_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "ionRouteDataChanged", 7);
    /**
     * Relative path that needs to match in order for this route to apply.
     *
     * Accepts paths similar to expressjs so that you can define parameters
     * in the url /foo/:bar where bar would be available in incoming props.
     */

    this.url = '';
  }

  onUpdate(newValue) {
    this.ionRouteDataChanged.emit(newValue);
  }

  onComponentProps(newValue, oldValue) {
    if (newValue === oldValue) {
      return;
    }

    const keys1 = newValue ? Object.keys(newValue) : [];
    const keys2 = oldValue ? Object.keys(oldValue) : [];

    if (keys1.length !== keys2.length) {
      this.onUpdate(newValue);
      return;
    }

    for (const key of keys1) {
      if (newValue[key] !== oldValue[key]) {
        this.onUpdate(newValue);
        return;
      }
    }
  }

  connectedCallback() {
    this.ionRouteDataChanged.emit();
  }

  static get watchers() {
    return {
      "url": ["onUpdate"],
      "component": ["onUpdate"],
      "componentProps": ["onComponentProps"]
    };
  }

};
const RouteRedirect = class {
  constructor(hostRef) {
    (0,_index_1a99aeb7_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
    this.ionRouteRedirectChanged = (0,_index_1a99aeb7_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "ionRouteRedirectChanged", 7);
  }

  propDidChange() {
    this.ionRouteRedirectChanged.emit();
  }

  connectedCallback() {
    this.ionRouteRedirectChanged.emit();
  }

  static get watchers() {
    return {
      "from": ["propDidChange"],
      "to": ["propDidChange"]
    };
  }

};
const ROUTER_INTENT_NONE = 'root';
const ROUTER_INTENT_FORWARD = 'forward';
const ROUTER_INTENT_BACK = 'back';
/** Join the non empty segments with "/". */

const generatePath = segments => {
  const path = segments.filter(s => s.length > 0).join('/');
  return '/' + path;
};

const generateUrl = (segments, useHash, queryString) => {
  let url = generatePath(segments);

  if (useHash) {
    url = '#' + url;
  }

  if (queryString !== undefined) {
    url += '?' + queryString;
  }

  return url;
};

const writeSegments = (history, root, useHash, segments, direction, state, queryString) => {
  const url = generateUrl([...parsePath(root).segments, ...segments], useHash, queryString);

  if (direction === ROUTER_INTENT_FORWARD) {
    history.pushState(state, '', url);
  } else {
    history.replaceState(state, '', url);
  }
};
/**
 * Transforms a chain to a list of segments.
 *
 * Notes:
 * - parameter segments of the form :param are replaced with their value,
 * - null is returned when a value is missing for any parameter segment.
 */


const chainToSegments = chain => {
  const segments = [];

  for (const route of chain) {
    for (const segment of route.segments) {
      if (segment[0] === ':') {
        const param = route.params && route.params[segment.slice(1)];

        if (!param) {
          return null;
        }

        segments.push(param);
      } else if (segment !== '') {
        segments.push(segment);
      }
    }
  }

  return segments;
};
/**
 * Removes the prefix segments from the path segments.
 *
 * Return:
 * - null when the path segments do not start with the passed prefix,
 * - the path segments after the prefix otherwise.
 */


const removePrefix = (prefix, segments) => {
  if (prefix.length > segments.length) {
    return null;
  }

  if (prefix.length <= 1 && prefix[0] === '') {
    return segments;
  }

  for (let i = 0; i < prefix.length; i++) {
    if (prefix[i] !== segments[i]) {
      return null;
    }
  }

  if (segments.length === prefix.length) {
    return [''];
  }

  return segments.slice(prefix.length);
};

const readSegments = (loc, root, useHash) => {
  const prefix = parsePath(root).segments;
  const pathname = useHash ? loc.hash.slice(1) : loc.pathname;
  const segments = parsePath(pathname).segments;
  return removePrefix(prefix, segments);
};
/**
 * Parses the path to:
 * - segments an array of '/' separated parts,
 * - queryString (undefined when no query string).
 */


const parsePath = path => {
  let segments = [''];
  let queryString;

  if (path != null) {
    const qsStart = path.indexOf('?');

    if (qsStart > -1) {
      queryString = path.substring(qsStart + 1);
      path = path.substring(0, qsStart);
    }

    segments = path.split('/').map(s => s.trim()).filter(s => s.length > 0);

    if (segments.length === 0) {
      segments = [''];
    }
  }

  return {
    segments,
    queryString
  };
};

const printRoutes = routes => {
  console.group(`[ion-core] ROUTES[${routes.length}]`);

  for (const chain of routes) {
    const segments = [];
    chain.forEach(r => segments.push(...r.segments));
    const ids = chain.map(r => r.id);
    console.debug(`%c ${generatePath(segments)}`, 'font-weight: bold; padding-left: 20px', '=>\t', `(${ids.join(', ')})`);
  }

  console.groupEnd();
};

const printRedirects = redirects => {
  console.group(`[ion-core] REDIRECTS[${redirects.length}]`);

  for (const redirect of redirects) {
    if (redirect.to) {
      console.debug('FROM: ', `$c ${generatePath(redirect.from)}`, 'font-weight: bold', ' TO: ', `$c ${generatePath(redirect.to.segments)}`, 'font-weight: bold');
    }
  }

  console.groupEnd();
};
/**
 * Activates the passed route chain.
 *
 * There must be exactly one outlet per route entry in the chain.
 *
 * The methods calls setRouteId on each of the outlet with the corresponding route entry in the chain.
 * setRouteId will create or select the view in the outlet.
 */


const writeNavState = /*#__PURE__*/function () {
  var _ref = (0,C_proyecto_Ionic_Proyecto_semestral_proyecto_semestral_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (root, chain, direction, index, changed = false, animation) {
    try {
      // find next navigation outlet in the DOM
      const outlet = searchNavNode(root); // make sure we can continue interacting the DOM, otherwise abort

      if (index >= chain.length || !outlet) {
        return changed;
      }

      yield new Promise(resolve => (0,_helpers_4d272360_js__WEBPACK_IMPORTED_MODULE_2__.c)(outlet, resolve));
      const route = chain[index];
      const result = yield outlet.setRouteId(route.id, route.params, direction, animation); // if the outlet changed the page, reset navigation to neutral (no direction)
      // this means nested outlets will not animate

      if (result.changed) {
        direction = ROUTER_INTENT_NONE;
        changed = true;
      } // recursively set nested outlets


      changed = yield writeNavState(result.element, chain, direction, index + 1, changed, animation); // once all nested outlets are visible let's make the parent visible too,
      // using markVisible prevents flickering

      if (result.markVisible) {
        yield result.markVisible();
      }

      return changed;
    } catch (e) {
      console.error(e);
      return false;
    }
  });

  return function writeNavState(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Recursively walks the outlet in the DOM.
 *
 * The function returns a list of RouteID corresponding to each of the outlet and the last outlet without a RouteID.
 */


const readNavState = /*#__PURE__*/function () {
  var _ref2 = (0,C_proyecto_Ionic_Proyecto_semestral_proyecto_semestral_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (root) {
    const ids = [];
    let outlet;
    let node = root; // eslint-disable-next-line no-cond-assign

    while (outlet = searchNavNode(node)) {
      const id = yield outlet.getRouteId();

      if (id) {
        node = id.element;
        id.element = undefined;
        ids.push(id);
      } else {
        break;
      }
    }

    return {
      ids,
      outlet
    };
  });

  return function readNavState(_x5) {
    return _ref2.apply(this, arguments);
  };
}();

const waitUntilNavNode = () => {
  if (searchNavNode(document.body)) {
    return Promise.resolve();
  }

  return new Promise(resolve => {
    window.addEventListener('ionNavWillLoad', () => resolve(), {
      once: true
    });
  });
};
/** Selector for all the outlets supported by the router. */


const OUTLET_SELECTOR = ':not([no-router]) ion-nav, :not([no-router]) ion-tabs, :not([no-router]) ion-router-outlet';

const searchNavNode = root => {
  if (!root) {
    return undefined;
  }

  if (root.matches(OUTLET_SELECTOR)) {
    return root;
  }

  const outlet = root.querySelector(OUTLET_SELECTOR);
  return outlet !== null && outlet !== void 0 ? outlet : undefined;
};
/**
 * Returns whether the given redirect matches the given path segments.
 *
 * A redirect matches when the segments of the path and redirect.from are equal.
 * Note that segments are only checked until redirect.from contains a '*' which matches any path segment.
 * The path ['some', 'path', 'to', 'page'] matches both ['some', 'path', 'to', 'page'] and ['some', 'path', '*'].
 */


const matchesRedirect = (segments, redirect) => {
  const {
    from,
    to
  } = redirect;

  if (to === undefined) {
    return false;
  }

  if (from.length > segments.length) {
    return false;
  }

  for (let i = 0; i < from.length; i++) {
    const expected = from[i];

    if (expected === '*') {
      return true;
    }

    if (expected !== segments[i]) {
      return false;
    }
  }

  return from.length === segments.length;
};
/** Returns the first redirect matching the path segments or undefined when no match found. */


const findRouteRedirect = (segments, redirects) => {
  return redirects.find(redirect => matchesRedirect(segments, redirect));
};

const matchesIDs = (ids, chain) => {
  const len = Math.min(ids.length, chain.length);
  let score = 0;

  for (let i = 0; i < len; i++) {
    const routeId = ids[i];
    const routeChain = chain[i]; // Skip results where the route id does not match the chain at the same index

    if (routeId.id.toLowerCase() !== routeChain.id) {
      break;
    }

    if (routeId.params) {
      const routeIdParams = Object.keys(routeId.params); // Only compare routes with the chain that have the same number of parameters.

      if (routeIdParams.length === routeChain.segments.length) {
        // Maps the route's params into a path based on the path variable names,
        // to compare against the route chain format.
        //
        // Before:
        // ```ts
        // {
        //  params: {
        //    s1: 'a',
        //    s2: 'b'
        //  }
        // }
        // ```
        //
        // After:
        // ```ts
        // [':s1',':s2']
        // ```
        //
        const pathWithParams = routeIdParams.map(key => `:${key}`);

        for (let j = 0; j < pathWithParams.length; j++) {
          // Skip results where the path variable is not a match
          if (pathWithParams[j].toLowerCase() !== routeChain.segments[j]) {
            break;
          } // Weight path matches for the same index higher.


          score++;
        }
      }
    } // Weight id matches


    score++;
  }

  return score;
};
/**
 * Matches the segments against the chain.
 *
 * Returns:
 * - null when there is no match,
 * - a chain with the params properties updated with the parameter segments on match.
 */


const matchesSegments = (segments, chain) => {
  const inputSegments = new RouterSegments(segments);
  let matchesDefault = false;
  let allparams;

  for (let i = 0; i < chain.length; i++) {
    const chainSegments = chain[i].segments;

    if (chainSegments[0] === '') {
      matchesDefault = true;
    } else {
      for (const segment of chainSegments) {
        const data = inputSegments.next(); // data param

        if (segment[0] === ':') {
          if (data === '') {
            return null;
          }

          allparams = allparams || [];
          const params = allparams[i] || (allparams[i] = {});
          params[segment.slice(1)] = data;
        } else if (data !== segment) {
          return null;
        }
      }

      matchesDefault = false;
    }
  }

  const matches = matchesDefault ? matchesDefault === (inputSegments.next() === '') : true;

  if (!matches) {
    return null;
  }

  if (allparams) {
    return chain.map((route, i) => ({
      id: route.id,
      segments: route.segments,
      params: mergeParams(route.params, allparams[i]),
      beforeEnter: route.beforeEnter,
      beforeLeave: route.beforeLeave
    }));
  }

  return chain;
};
/**
 * Merges the route parameter objects.
 * Returns undefined when both parameters are undefined.
 */


const mergeParams = (a, b) => {
  return a || b ? Object.assign(Object.assign({}, a), b) : undefined;
};
/**
 * Finds the best match for the ids in the chains.
 *
 * Returns the best match or null when no match is found.
 * When a chain is returned the parameters are updated from the RouteIDs.
 * That is they contain both the componentProps of the <ion-route> and the parameter segment.
 */


const findChainForIDs = (ids, chains) => {
  let match = null;
  let maxMatches = 0;

  for (const chain of chains) {
    const score = matchesIDs(ids, chain);

    if (score > maxMatches) {
      match = chain;
      maxMatches = score;
    }
  }

  if (match) {
    return match.map((route, i) => {
      var _a;

      return {
        id: route.id,
        segments: route.segments,
        params: mergeParams(route.params, (_a = ids[i]) === null || _a === void 0 ? void 0 : _a.params)
      };
    });
  }

  return null;
};
/**
 * Finds the best match for the segments in the chains.
 *
 * Returns the best match or null when no match is found.
 * When a chain is returned the parameters are updated from the segments.
 * That is they contain both the componentProps of the <ion-route> and the parameter segments.
 */


const findChainForSegments = (segments, chains) => {
  let match = null;
  let bestScore = 0;

  for (const chain of chains) {
    const matchedChain = matchesSegments(segments, chain);

    if (matchedChain !== null) {
      const score = computePriority(matchedChain);

      if (score > bestScore) {
        bestScore = score;
        match = matchedChain;
      }
    }
  }

  return match;
};
/**
 * Computes the priority of a chain.
 *
 * Parameter segments are given a lower priority over fixed segments.
 *
 * Considering the following 2 chains matching the path /path/to/page:
 * - /path/to/:where
 * - /path/to/page
 *
 * The second one will be given a higher priority because "page" is a fixed segment (vs ":where", a parameter segment).
 */


const computePriority = chain => {
  let score = 1;
  let level = 1;

  for (const route of chain) {
    for (const segment of route.segments) {
      if (segment[0] === ':') {
        score += Math.pow(1, level);
      } else if (segment !== '') {
        score += Math.pow(2, level);
      }

      level++;
    }
  }

  return score;
};

class RouterSegments {
  constructor(segments) {
    this.segments = segments.slice();
  }

  next() {
    if (this.segments.length > 0) {
      return this.segments.shift();
    }

    return '';
  }

}

const readProp = (el, prop) => {
  if (prop in el) {
    return el[prop];
  }

  if (el.hasAttribute(prop)) {
    return el.getAttribute(prop);
  }

  return null;
};
/**
 * Extracts the redirects (that is <ion-route-redirect> elements inside the root).
 *
 * The redirects are returned as a list of RouteRedirect.
 */


const readRedirects = root => {
  return Array.from(root.children).filter(el => el.tagName === 'ION-ROUTE-REDIRECT').map(el => {
    const to = readProp(el, 'to');
    return {
      from: parsePath(readProp(el, 'from')).segments,
      to: to == null ? undefined : parsePath(to)
    };
  });
};
/**
 * Extracts all the routes (that is <ion-route> elements inside the root).
 *
 * The routes are returned as a list of chains - the flattened tree.
 */


const readRoutes = root => {
  return flattenRouterTree(readRouteNodes(root));
};
/**
 * Reads the route nodes as a tree modeled after the DOM tree of <ion-route> elements.
 *
 * Note: routes without a component are ignored together with their children.
 */


const readRouteNodes = node => {
  return Array.from(node.children).filter(el => el.tagName === 'ION-ROUTE' && el.component).map(el => {
    const component = readProp(el, 'component');
    return {
      segments: parsePath(readProp(el, 'url')).segments,
      id: component.toLowerCase(),
      params: el.componentProps,
      beforeLeave: el.beforeLeave,
      beforeEnter: el.beforeEnter,
      children: readRouteNodes(el)
    };
  });
};
/**
 * Flattens a RouterTree in a list of chains.
 *
 * Each chain represents a path from the root node to a terminal node.
 */


const flattenRouterTree = nodes => {
  const chains = [];

  for (const node of nodes) {
    flattenNode([], chains, node);
  }

  return chains;
};
/** Flattens a route node recursively and push each branch to the chains list. */


const flattenNode = (chain, chains, node) => {
  chain = [...chain, {
    id: node.id,
    segments: node.segments,
    params: node.params,
    beforeLeave: node.beforeLeave,
    beforeEnter: node.beforeEnter
  }];

  if (node.children.length === 0) {
    chains.push(chain);
    return;
  }

  for (const child of node.children) {
    flattenNode(chain, chains, child);
  }
};

const Router = class {
  constructor(hostRef) {
    (0,_index_1a99aeb7_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
    this.ionRouteWillChange = (0,_index_1a99aeb7_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "ionRouteWillChange", 7);
    this.ionRouteDidChange = (0,_index_1a99aeb7_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "ionRouteDidChange", 7);
    this.previousPath = null;
    this.busy = false;
    this.state = 0;
    this.lastState = 0;
    /**
     * The root path to use when matching URLs. By default, this is set to "/", but you can specify
     * an alternate prefix for all URL paths.
     */

    this.root = '/';
    /**
     * The router can work in two "modes":
     * - With hash: `/index.html#/path/to/page`
     * - Without hash: `/path/to/page`
     *
     * Using one or another might depend in the requirements of your app and/or where it's deployed.
     *
     * Usually "hash-less" navigation works better for SEO and it's more user friendly too, but it might
     * requires additional server-side configuration in order to properly work.
     *
     * On the other side hash-navigation is much easier to deploy, it even works over the file protocol.
     *
     * By default, this property is `true`, change to `false` to allow hash-less URLs.
     */

    this.useHash = true;
  }

  componentWillLoad() {
    var _this = this;

    return (0,C_proyecto_Ionic_Proyecto_semestral_proyecto_semestral_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield waitUntilNavNode();
      const canProceed = yield _this.runGuards(_this.getSegments());

      if (canProceed !== true) {
        if (typeof canProceed === 'object') {
          const {
            redirect
          } = canProceed;
          const path = parsePath(redirect);

          _this.setSegments(path.segments, ROUTER_INTENT_NONE, path.queryString);

          yield _this.writeNavStateRoot(path.segments, ROUTER_INTENT_NONE);
        }
      } else {
        yield _this.onRoutesChanged();
      }
    })();
  }

  componentDidLoad() {
    window.addEventListener('ionRouteRedirectChanged', (0,_helpers_4d272360_js__WEBPACK_IMPORTED_MODULE_2__.q)(this.onRedirectChanged.bind(this), 10));
    window.addEventListener('ionRouteDataChanged', (0,_helpers_4d272360_js__WEBPACK_IMPORTED_MODULE_2__.q)(this.onRoutesChanged.bind(this), 100));
  }

  onPopState() {
    var _this2 = this;

    return (0,C_proyecto_Ionic_Proyecto_semestral_proyecto_semestral_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const direction = _this2.historyDirection();

      let segments = _this2.getSegments();

      const canProceed = yield _this2.runGuards(segments);

      if (canProceed !== true) {
        if (typeof canProceed === 'object') {
          segments = parsePath(canProceed.redirect).segments;
        } else {
          return false;
        }
      }

      return _this2.writeNavStateRoot(segments, direction);
    })();
  }

  onBackButton(ev) {
    ev.detail.register(0, processNextHandler => {
      this.back();
      processNextHandler();
    });
  }
  /** @internal */


  canTransition() {
    var _this3 = this;

    return (0,C_proyecto_Ionic_Proyecto_semestral_proyecto_semestral_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const canProceed = yield _this3.runGuards();

      if (canProceed !== true) {
        if (typeof canProceed === 'object') {
          return canProceed.redirect;
        } else {
          return false;
        }
      }

      return true;
    })();
  }
  /**
   * Navigate to the specified path.
   *
   * @param path The path to navigate to.
   * @param direction The direction of the animation. Defaults to `"forward"`.
   */


  push(path, direction = 'forward', animation) {
    var _this4 = this;

    return (0,C_proyecto_Ionic_Proyecto_semestral_proyecto_semestral_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      var _a;

      if (path.startsWith('.')) {
        const currentPath = (_a = _this4.previousPath) !== null && _a !== void 0 ? _a : '/'; // Convert currentPath to an URL by pre-pending a protocol and a host to resolve the relative path.

        const url = new URL(path, `https://host/${currentPath}`);
        path = url.pathname + url.search;
      }

      let parsedPath = parsePath(path);
      const canProceed = yield _this4.runGuards(parsedPath.segments);

      if (canProceed !== true) {
        if (typeof canProceed === 'object') {
          parsedPath = parsePath(canProceed.redirect);
        } else {
          return false;
        }
      }

      _this4.setSegments(parsedPath.segments, direction, parsedPath.queryString);

      return _this4.writeNavStateRoot(parsedPath.segments, direction, animation);
    })();
  }
  /** Go back to previous page in the window.history. */


  back() {
    window.history.back();
    return Promise.resolve(this.waitPromise);
  }
  /** @internal */


  printDebug() {
    var _this5 = this;

    return (0,C_proyecto_Ionic_Proyecto_semestral_proyecto_semestral_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      printRoutes(readRoutes(_this5.el));
      printRedirects(readRedirects(_this5.el));
    })();
  }
  /** @internal */


  navChanged(direction) {
    var _this6 = this;

    return (0,C_proyecto_Ionic_Proyecto_semestral_proyecto_semestral_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (_this6.busy) {
        console.warn('[ion-router] router is busy, navChanged was cancelled');
        return false;
      }

      const {
        ids,
        outlet
      } = yield readNavState(window.document.body);
      const routes = readRoutes(_this6.el);
      const chain = findChainForIDs(ids, routes);

      if (!chain) {
        console.warn('[ion-router] no matching URL for ', ids.map(i => i.id));
        return false;
      }

      const segments = chainToSegments(chain);

      if (!segments) {
        console.warn('[ion-router] router could not match path because some required param is missing');
        return false;
      }

      _this6.setSegments(segments, direction);

      yield _this6.safeWriteNavState(outlet, chain, ROUTER_INTENT_NONE, segments, null, ids.length);
      return true;
    })();
  }
  /** This handler gets called when a `ion-route-redirect` component is added to the DOM or if the from or to property of such node changes. */


  onRedirectChanged() {
    const segments = this.getSegments();

    if (segments && findRouteRedirect(segments, readRedirects(this.el))) {
      this.writeNavStateRoot(segments, ROUTER_INTENT_NONE);
    }
  }
  /** This handler gets called when a `ion-route` component is added to the DOM or if the from or to property of such node changes. */


  onRoutesChanged() {
    return this.writeNavStateRoot(this.getSegments(), ROUTER_INTENT_NONE);
  }

  historyDirection() {
    var _a;

    const win = window;

    if (win.history.state === null) {
      this.state++;
      win.history.replaceState(this.state, win.document.title, (_a = win.document.location) === null || _a === void 0 ? void 0 : _a.href);
    }

    const state = win.history.state;
    const lastState = this.lastState;
    this.lastState = state;

    if (state > lastState || state >= lastState && lastState > 0) {
      return ROUTER_INTENT_FORWARD;
    }

    if (state < lastState) {
      return ROUTER_INTENT_BACK;
    }

    return ROUTER_INTENT_NONE;
  }

  writeNavStateRoot(segments, direction, animation) {
    var _this7 = this;

    return (0,C_proyecto_Ionic_Proyecto_semestral_proyecto_semestral_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (!segments) {
        console.error('[ion-router] URL is not part of the routing set');
        return false;
      } // lookup redirect rule


      const redirects = readRedirects(_this7.el);
      const redirect = findRouteRedirect(segments, redirects);
      let redirectFrom = null;

      if (redirect) {
        const {
          segments: toSegments,
          queryString
        } = redirect.to;

        _this7.setSegments(toSegments, direction, queryString);

        redirectFrom = redirect.from;
        segments = toSegments;
      } // lookup route chain


      const routes = readRoutes(_this7.el);
      const chain = findChainForSegments(segments, routes);

      if (!chain) {
        console.error('[ion-router] the path does not match any route');
        return false;
      } // write DOM give


      return _this7.safeWriteNavState(document.body, chain, direction, segments, redirectFrom, 0, animation);
    })();
  }

  safeWriteNavState(node, chain, direction, segments, redirectFrom, index = 0, animation) {
    var _this8 = this;

    return (0,C_proyecto_Ionic_Proyecto_semestral_proyecto_semestral_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const unlock = yield _this8.lock();
      let changed = false;

      try {
        changed = yield _this8.writeNavState(node, chain, direction, segments, redirectFrom, index, animation);
      } catch (e) {
        console.error(e);
      }

      unlock();
      return changed;
    })();
  }

  lock() {
    var _this9 = this;

    return (0,C_proyecto_Ionic_Proyecto_semestral_proyecto_semestral_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const p = _this9.waitPromise;
      let resolve;
      _this9.waitPromise = new Promise(r => resolve = r);

      if (p !== undefined) {
        yield p;
      }

      return resolve;
    })();
  }
  /**
   * Executes the beforeLeave hook of the source route and the beforeEnter hook of the target route if they exist.
   *
   * When the beforeLeave hook does not return true (to allow navigating) then that value is returned early and the beforeEnter is executed.
   * Otherwise the beforeEnterHook hook of the target route is executed.
   */


  runGuards(to = this.getSegments(), from) {
    var _this10 = this;

    return (0,C_proyecto_Ionic_Proyecto_semestral_proyecto_semestral_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (from === undefined) {
        from = parsePath(_this10.previousPath).segments;
      }

      if (!to || !from) {
        return true;
      }

      const routes = readRoutes(_this10.el);
      const fromChain = findChainForSegments(from, routes);
      const beforeLeaveHook = fromChain && fromChain[fromChain.length - 1].beforeLeave;
      const canLeave = beforeLeaveHook ? yield beforeLeaveHook() : true;

      if (canLeave === false || typeof canLeave === 'object') {
        return canLeave;
      }

      const toChain = findChainForSegments(to, routes);
      const beforeEnterHook = toChain && toChain[toChain.length - 1].beforeEnter;
      return beforeEnterHook ? beforeEnterHook() : true;
    })();
  }

  writeNavState(node, chain, direction, segments, redirectFrom, index = 0, animation) {
    var _this11 = this;

    return (0,C_proyecto_Ionic_Proyecto_semestral_proyecto_semestral_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (_this11.busy) {
        console.warn('[ion-router] router is busy, transition was cancelled');
        return false;
      }

      _this11.busy = true; // generate route event and emit will change

      const routeEvent = _this11.routeChangeEvent(segments, redirectFrom);

      if (routeEvent) {
        _this11.ionRouteWillChange.emit(routeEvent);
      }

      const changed = yield writeNavState(node, chain, direction, index, false, animation);
      _this11.busy = false; // emit did change

      if (routeEvent) {
        _this11.ionRouteDidChange.emit(routeEvent);
      }

      return changed;
    })();
  }

  setSegments(segments, direction, queryString) {
    this.state++;
    writeSegments(window.history, this.root, this.useHash, segments, direction, this.state, queryString);
  }

  getSegments() {
    return readSegments(window.location, this.root, this.useHash);
  }

  routeChangeEvent(toSegments, redirectFromSegments) {
    const from = this.previousPath;
    const to = generatePath(toSegments);
    this.previousPath = to;

    if (to === from) {
      return null;
    }

    const redirectedFrom = redirectFromSegments ? generatePath(redirectFromSegments) : null;
    return {
      from,
      redirectedFrom,
      to
    };
  }

  get el() {
    return (0,_index_1a99aeb7_js__WEBPACK_IMPORTED_MODULE_1__.i)(this);
  }

};
const routerLinkCss = ":host{--background:transparent;--color:var(--ion-color-primary, #3880ff);background:var(--background);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}a{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit}";
const RouterLink = class {
  constructor(hostRef) {
    (0,_index_1a99aeb7_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
    /**
     * When using a router, it specifies the transition direction when navigating to
     * another page using `href`.
     */

    this.routerDirection = 'forward';

    this.onClick = ev => {
      (0,_theme_7670341c_js__WEBPACK_IMPORTED_MODULE_4__.o)(this.href, ev, this.routerDirection, this.routerAnimation);
    };
  }

  render() {
    const mode = (0,_ionic_global_04e268e7_js__WEBPACK_IMPORTED_MODULE_3__.b)(this);
    const attrs = {
      href: this.href,
      rel: this.rel,
      target: this.target
    };
    return (0,_index_1a99aeb7_js__WEBPACK_IMPORTED_MODULE_1__.h)(_index_1a99aeb7_js__WEBPACK_IMPORTED_MODULE_1__.H, {
      onClick: this.onClick,
      class: (0,_theme_7670341c_js__WEBPACK_IMPORTED_MODULE_4__.c)(this.color, {
        [mode]: true,
        'ion-activatable': true
      })
    }, (0,_index_1a99aeb7_js__WEBPACK_IMPORTED_MODULE_1__.h)("a", Object.assign({}, attrs), (0,_index_1a99aeb7_js__WEBPACK_IMPORTED_MODULE_1__.h)("slot", null)));
  }

};
RouterLink.style = routerLinkCss;


/***/ }),

/***/ 320:
/*!*************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/theme-7670341c.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": () => (/* binding */ createColorClasses),
/* harmony export */   "g": () => (/* binding */ getClassMap),
/* harmony export */   "h": () => (/* binding */ hostContext),
/* harmony export */   "o": () => (/* binding */ openURL)
/* harmony export */ });
/* harmony import */ var C_proyecto_Ionic_Proyecto_semestral_proyecto_semestral_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 1670);


/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const hostContext = (selector, el) => {
  return el.closest(selector) !== null;
};
/**
 * Create the mode and color classes for the component based on the classes passed in
 */


const createColorClasses = (color, cssClassMap) => {
  return typeof color === 'string' && color.length > 0 ? Object.assign({
    'ion-color': true,
    [`ion-color-${color}`]: true
  }, cssClassMap) : cssClassMap;
};

const getClassList = classes => {
  if (classes !== undefined) {
    const array = Array.isArray(classes) ? classes : classes.split(' ');
    return array.filter(c => c != null).map(c => c.trim()).filter(c => c !== '');
  }

  return [];
};

const getClassMap = classes => {
  const map = {};
  getClassList(classes).forEach(c => map[c] = true);
  return map;
};

const SCHEME = /^[a-z][a-z0-9+\-.]*:/;

const openURL = /*#__PURE__*/function () {
  var _ref = (0,C_proyecto_Ionic_Proyecto_semestral_proyecto_semestral_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (url, ev, direction, animation) {
    if (url != null && url[0] !== '#' && !SCHEME.test(url)) {
      const router = document.querySelector('ion-router');

      if (router) {
        if (ev != null) {
          ev.preventDefault();
        }

        return router.push(url, direction, animation);
      }
    }

    return false;
  });

  return function openURL(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2lvbmljX2NvcmVfZGlzdF9lc21faW9uLXJvdXRlXzRfZW50cnlfanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLE1BQU1rQixLQUFLLEdBQUcsTUFBTTtFQUNsQkMsV0FBVyxDQUFDQyxPQUFELEVBQVU7SUFDbkJuQixxREFBZ0IsQ0FBQyxJQUFELEVBQU9tQixPQUFQLENBQWhCO0lBQ0EsS0FBS0MsbUJBQUwsR0FBMkJsQixxREFBVyxDQUFDLElBQUQsRUFBTyxxQkFBUCxFQUE4QixDQUE5QixDQUF0QztJQUNBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7SUFDSSxLQUFLbUIsR0FBTCxHQUFXLEVBQVg7RUFDRDs7RUFDREMsUUFBUSxDQUFDQyxRQUFELEVBQVc7SUFDakIsS0FBS0gsbUJBQUwsQ0FBeUJJLElBQXpCLENBQThCRCxRQUE5QjtFQUNEOztFQUNERSxnQkFBZ0IsQ0FBQ0YsUUFBRCxFQUFXRyxRQUFYLEVBQXFCO0lBQ25DLElBQUlILFFBQVEsS0FBS0csUUFBakIsRUFBMkI7TUFDekI7SUFDRDs7SUFDRCxNQUFNQyxLQUFLLEdBQUdKLFFBQVEsR0FBR0ssTUFBTSxDQUFDQyxJQUFQLENBQVlOLFFBQVosQ0FBSCxHQUEyQixFQUFqRDtJQUNBLE1BQU1PLEtBQUssR0FBR0osUUFBUSxHQUFHRSxNQUFNLENBQUNDLElBQVAsQ0FBWUgsUUFBWixDQUFILEdBQTJCLEVBQWpEOztJQUNBLElBQUlDLEtBQUssQ0FBQ0ksTUFBTixLQUFpQkQsS0FBSyxDQUFDQyxNQUEzQixFQUFtQztNQUNqQyxLQUFLVCxRQUFMLENBQWNDLFFBQWQ7TUFDQTtJQUNEOztJQUNELEtBQUssTUFBTVMsR0FBWCxJQUFrQkwsS0FBbEIsRUFBeUI7TUFDdkIsSUFBSUosUUFBUSxDQUFDUyxHQUFELENBQVIsS0FBa0JOLFFBQVEsQ0FBQ00sR0FBRCxDQUE5QixF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QUssRUFIaEIsQ0FBUDtFQUlEOztFQUNELE9BQU8sRUFBUDtBQUNELENBVEQ7O0FBVUEsTUFBTXFQLFdBQVcsR0FBSUgsT0FBRCxJQUFhO0VBQy9CLE1BQU03SyxHQUFHLEdBQUcsRUFBWjtFQUNBNEssWUFBWSxDQUFDQyxPQUFELENBQVosQ0FBc0J2SyxPQUF0QixDQUErQjNFLENBQUQsSUFBUXFFLEdBQUcsQ0FBQ3JFLENBQUQsQ0FBSCxHQUFTLElBQS9DO0VBQ0EsT0FBT3FFLEdBQVA7QUFDRCxDQUpEOztBQUtBLE1BQU1pTCxNQUFNLEdBQUcsc0JBQWY7O0FBQ0EsTUFBTS9PLE9BQU87RUFBQSx5S0FBRyxXQUFPTSxHQUFQLEVBQVk2SyxFQUFaLEVBQWdCNUksU0FBaEIsRUFBMkIwQyxTQUEzQixFQUF5QztJQUN2RCxJQUFJM0UsR0FBRyxJQUFJLElBQVAsSUFBZUEsR0FBRyxDQUFDLENBQUQsQ0FBSCxLQUFXLEdBQTFCLElBQWlDLENBQUN5TyxNQUFNLENBQUNDLElBQVAsQ0FBWTFPLEdBQVosQ0FBdEMsRUFBd0Q7TUFDdEQsTUFBTTJPLE1BQU0sR0FBR2xKLFFBQVEsQ0FBQ08sYUFBVCxDQUF1QixZQUF2QixDQUFmOztNQUNBLElBQUkySSxNQUFKLEVBQVk7UUFDVixJQUFJOUQsRUFBRSxJQUFJLElBQVYsRUFBZ0I7VUFDZEEsRUFBRSxDQUFDK0QsY0FBSDtRQUNEOztRQUNELE9BQU9ELE1BQU0sQ0FBQzlMLElBQVAsQ0FBWTdDLEdBQVosRUFBaUJpQyxTQUFqQixFQUE0QjBDLFNBQTVCLENBQVA7TUFDRDtJQUNGOztJQUNELE9BQU8sS0FBUDtFQUNELENBWFk7O0VBQUEsZ0JBQVBqRixPQUFPO0lBQUE7RUFBQTtBQUFBLEdBQWIiLCJzb3VyY2VzIjpbIi4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtL2lvbi1yb3V0ZV80LmVudHJ5LmpzIiwiLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20vdGhlbWUtNzY3MDM0MWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHIgYXMgcmVnaXN0ZXJJbnN0YW5jZSwgZSBhcyBjcmVhdGVFdmVudCwgaSBhcyBnZXRFbGVtZW50LCBoLCBIIGFzIEhvc3QgfSBmcm9tICcuL2luZGV4LTFhOTlhZWI3LmpzJztcbmltcG9ydCB7IGMgYXMgY29tcG9uZW50T25SZWFkeSwgcSBhcyBkZWJvdW5jZSB9IGZyb20gJy4vaGVscGVycy00ZDI3MjM2MC5qcyc7XG5pbXBvcnQgeyBiIGFzIGdldElvbk1vZGUgfSBmcm9tICcuL2lvbmljLWdsb2JhbC0wNGUyNjhlNy5qcyc7XG5pbXBvcnQgeyBvIGFzIG9wZW5VUkwsIGMgYXMgY3JlYXRlQ29sb3JDbGFzc2VzIH0gZnJvbSAnLi90aGVtZS03NjcwMzQxYy5qcyc7XG5cbmNvbnN0IFJvdXRlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICB0aGlzLmlvblJvdXRlRGF0YUNoYW5nZWQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImlvblJvdXRlRGF0YUNoYW5nZWRcIiwgNyk7XG4gICAgLyoqXG4gICAgICogUmVsYXRpdmUgcGF0aCB0aGF0IG5lZWRzIHRvIG1hdGNoIGluIG9yZGVyIGZvciB0aGlzIHJvdXRlIHRvIGFwcGx5LlxuICAgICAqXG4gICAgICogQWNjZXB0cyBwYXRocyBzaW1pbGFyIHRvIGV4cHJlc3NqcyBzbyB0aGF0IHlvdSBjYW4gZGVmaW5lIHBhcmFtZXRlcnNcbiAgICAgKiBpbiB0aGUgdXJsIC9mb28vOmJhciB3aGVyZSBiYXIgd291bGQgYmUgYXZhaWxhYmxlIGluIGluY29taW5nIHByb3BzLlxuICAgICAqL1xuICAgIHRoaXMudXJsID0gJyc7XG4gIH1cbiAgb25VcGRhdGUobmV3VmFsdWUpIHtcbiAgICB0aGlzLmlvblJvdXRlRGF0YUNoYW5nZWQuZW1pdChuZXdWYWx1ZSk7XG4gIH1cbiAgb25Db21wb25lbnRQcm9wcyhuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICBpZiAobmV3VmFsdWUgPT09IG9sZFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGtleXMxID0gbmV3VmFsdWUgPyBPYmplY3Qua2V5cyhuZXdWYWx1ZSkgOiBbXTtcbiAgICBjb25zdCBrZXlzMiA9IG9sZFZhbHVlID8gT2JqZWN0LmtleXMob2xkVmFsdWUpIDogW107XG4gICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlKG5ld1ZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5czEpIHtcbiAgICAgIGlmIChuZXdWYWx1ZVtrZXldICE9PSBvbGRWYWx1ZVtrZXldKSB7XG4gICAgICAgIHRoaXMub25VcGRhdGUobmV3VmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuaW9uUm91dGVEYXRhQ2hhbmdlZC5lbWl0KCk7XG4gIH1cbiAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICBcInVybFwiOiBbXCJvblVwZGF0ZVwiXSxcbiAgICBcImNvbXBvbmVudFwiOiBbXCJvblVwZGF0ZVwiXSxcbiAgICBcImNvbXBvbmVudFByb3BzXCI6IFtcIm9uQ29tcG9uZW50UHJvcHNcIl1cbiAgfTsgfVxufTtcblxuY29uc3QgUm91dGVSZWRpcmVjdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgdGhpcy5pb25Sb3V0ZVJlZGlyZWN0Q2hhbmdlZCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiaW9uUm91dGVSZWRpcmVjdENoYW5nZWRcIiwgNyk7XG4gIH1cbiAgcHJvcERpZENoYW5nZSgpIHtcbiAgICB0aGlzLmlvblJvdXRlUmVkaXJlY3RDaGFuZ2VkLmVtaXQoKTtcbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmlvblJvdXRlUmVkaXJlY3RDaGFuZ2VkLmVtaXQoKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgIFwiZnJvbVwiOiBbXCJwcm9wRGlkQ2hhbmdlXCJdLFxuICAgIFwidG9cIjogW1wicHJvcERpZENoYW5nZVwiXVxuICB9OyB9XG59O1xuXG5jb25zdCBST1VURVJfSU5URU5UX05PTkUgPSAncm9vdCc7XG5jb25zdCBST1VURVJfSU5URU5UX0ZPUldBUkQgPSAnZm9yd2FyZCc7XG5jb25zdCBST1VURVJfSU5URU5UX0JBQ0sgPSAnYmFjayc7XG5cbi8qKiBKb2luIHRoZSBub24gZW1wdHkgc2VnbWVudHMgd2l0aCBcIi9cIi4gKi9cbmNvbnN0IGdlbmVyYXRlUGF0aCA9IChzZWdtZW50cykgPT4ge1xuICBjb25zdCBwYXRoID0gc2VnbWVudHMuZmlsdGVyKChzKSA9PiBzLmxlbmd0aCA+IDApLmpvaW4oJy8nKTtcbiAgcmV0dXJuICcvJyArIHBhdGg7XG59O1xuY29uc3QgZ2VuZXJhdGVVcmwgPSAoc2VnbWVudHMsIHVzZUhhc2gsIHF1ZXJ5U3RyaW5nKSA9PiB7XG4gIGxldCB1cmwgPSBnZW5lcmF0ZVBhdGgoc2VnbWVudHMpO1xuICBpZiAodXNlSGFzaCkge1xuICAgIHVybCA9ICcjJyArIHVybDtcbiAgfVxuICBpZiAocXVlcnlTdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIHVybCArPSAnPycgKyBxdWVyeVN0cmluZztcbiAgfVxuICByZXR1cm4gdXJsO1xufTtcbmNvbnN0IHdyaXRlU2VnbWVudHMgPSAoaGlzdG9yeSwgcm9vdCwgdXNlSGFzaCwgc2VnbWVudHMsIGRpcmVjdGlvbiwgc3RhdGUsIHF1ZXJ5U3RyaW5nKSA9PiB7XG4gIGNvbnN0IHVybCA9IGdlbmVyYXRlVXJsKFsuLi5wYXJzZVBhdGgocm9vdCkuc2VnbWVudHMsIC4uLnNlZ21lbnRzXSwgdXNlSGFzaCwgcXVlcnlTdHJpbmcpO1xuICBpZiAoZGlyZWN0aW9uID09PSBST1VURVJfSU5URU5UX0ZPUldBUkQpIHtcbiAgICBoaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgJycsIHVybCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsICcnLCB1cmwpO1xuICB9XG59O1xuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgY2hhaW4gdG8gYSBsaXN0IG9mIHNlZ21lbnRzLlxuICpcbiAqIE5vdGVzOlxuICogLSBwYXJhbWV0ZXIgc2VnbWVudHMgb2YgdGhlIGZvcm0gOnBhcmFtIGFyZSByZXBsYWNlZCB3aXRoIHRoZWlyIHZhbHVlLFxuICogLSBudWxsIGlzIHJldHVybmVkIHdoZW4gYSB2YWx1ZSBpcyBtaXNzaW5nIGZvciBhbnkgcGFyYW1ldGVyIHNlZ21lbnQuXG4gKi9cbmNvbnN0IGNoYWluVG9TZWdtZW50cyA9IChjaGFpbikgPT4ge1xuICBjb25zdCBzZWdtZW50cyA9IFtdO1xuICBmb3IgKGNvbnN0IHJvdXRlIG9mIGNoYWluKSB7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHJvdXRlLnNlZ21lbnRzKSB7XG4gICAgICBpZiAoc2VnbWVudFswXSA9PT0gJzonKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtID0gcm91dGUucGFyYW1zICYmIHJvdXRlLnBhcmFtc1tzZWdtZW50LnNsaWNlKDEpXTtcbiAgICAgICAgaWYgKCFwYXJhbSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHNlZ21lbnRzLnB1c2gocGFyYW0pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VnbWVudCAhPT0gJycpIHtcbiAgICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlZ21lbnRzO1xufTtcbi8qKlxuICogUmVtb3ZlcyB0aGUgcHJlZml4IHNlZ21lbnRzIGZyb20gdGhlIHBhdGggc2VnbWVudHMuXG4gKlxuICogUmV0dXJuOlxuICogLSBudWxsIHdoZW4gdGhlIHBhdGggc2VnbWVudHMgZG8gbm90IHN0YXJ0IHdpdGggdGhlIHBhc3NlZCBwcmVmaXgsXG4gKiAtIHRoZSBwYXRoIHNlZ21lbnRzIGFmdGVyIHRoZSBwcmVmaXggb3RoZXJ3aXNlLlxuICovXG5jb25zdCByZW1vdmVQcmVmaXggPSAocHJlZml4LCBzZWdtZW50cykgPT4ge1xuICBpZiAocHJlZml4Lmxlbmd0aCA+IHNlZ21lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwcmVmaXgubGVuZ3RoIDw9IDEgJiYgcHJlZml4WzBdID09PSAnJykge1xuICAgIHJldHVybiBzZWdtZW50cztcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZpeC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwcmVmaXhbaV0gIT09IHNlZ21lbnRzW2ldKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gcHJlZml4Lmxlbmd0aCkge1xuICAgIHJldHVybiBbJyddO1xuICB9XG4gIHJldHVybiBzZWdtZW50cy5zbGljZShwcmVmaXgubGVuZ3RoKTtcbn07XG5jb25zdCByZWFkU2VnbWVudHMgPSAobG9jLCByb290LCB1c2VIYXNoKSA9PiB7XG4gIGNvbnN0IHByZWZpeCA9IHBhcnNlUGF0aChyb290KS5zZWdtZW50cztcbiAgY29uc3QgcGF0aG5hbWUgPSB1c2VIYXNoID8gbG9jLmhhc2guc2xpY2UoMSkgOiBsb2MucGF0aG5hbWU7XG4gIGNvbnN0IHNlZ21lbnRzID0gcGFyc2VQYXRoKHBhdGhuYW1lKS5zZWdtZW50cztcbiAgcmV0dXJuIHJlbW92ZVByZWZpeChwcmVmaXgsIHNlZ21lbnRzKTtcbn07XG4vKipcbiAqIFBhcnNlcyB0aGUgcGF0aCB0bzpcbiAqIC0gc2VnbWVudHMgYW4gYXJyYXkgb2YgJy8nIHNlcGFyYXRlZCBwYXJ0cyxcbiAqIC0gcXVlcnlTdHJpbmcgKHVuZGVmaW5lZCB3aGVuIG5vIHF1ZXJ5IHN0cmluZykuXG4gKi9cbmNvbnN0IHBhcnNlUGF0aCA9IChwYXRoKSA9PiB7XG4gIGxldCBzZWdtZW50cyA9IFsnJ107XG4gIGxldCBxdWVyeVN0cmluZztcbiAgaWYgKHBhdGggIT0gbnVsbCkge1xuICAgIGNvbnN0IHFzU3RhcnQgPSBwYXRoLmluZGV4T2YoJz8nKTtcbiAgICBpZiAocXNTdGFydCA+IC0xKSB7XG4gICAgICBxdWVyeVN0cmluZyA9IHBhdGguc3Vic3RyaW5nKHFzU3RhcnQgKyAxKTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBxc1N0YXJ0KTtcbiAgICB9XG4gICAgc2VnbWVudHMgPSBwYXRoXG4gICAgICAuc3BsaXQoJy8nKVxuICAgICAgLm1hcCgocykgPT4gcy50cmltKCkpXG4gICAgICAuZmlsdGVyKChzKSA9PiBzLmxlbmd0aCA+IDApO1xuICAgIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHNlZ21lbnRzID0gWycnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgc2VnbWVudHMsIHF1ZXJ5U3RyaW5nIH07XG59O1xuXG5jb25zdCBwcmludFJvdXRlcyA9IChyb3V0ZXMpID0+IHtcbiAgY29uc29sZS5ncm91cChgW2lvbi1jb3JlXSBST1VURVNbJHtyb3V0ZXMubGVuZ3RofV1gKTtcbiAgZm9yIChjb25zdCBjaGFpbiBvZiByb3V0ZXMpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IFtdO1xuICAgIGNoYWluLmZvckVhY2goKHIpID0+IHNlZ21lbnRzLnB1c2goLi4uci5zZWdtZW50cykpO1xuICAgIGNvbnN0IGlkcyA9IGNoYWluLm1hcCgocikgPT4gci5pZCk7XG4gICAgY29uc29sZS5kZWJ1ZyhgJWMgJHtnZW5lcmF0ZVBhdGgoc2VnbWVudHMpfWAsICdmb250LXdlaWdodDogYm9sZDsgcGFkZGluZy1sZWZ0OiAyMHB4JywgJz0+XFx0JywgYCgke2lkcy5qb2luKCcsICcpfSlgKTtcbiAgfVxuICBjb25zb2xlLmdyb3VwRW5kKCk7XG59O1xuY29uc3QgcHJpbnRSZWRpcmVjdHMgPSAocmVkaXJlY3RzKSA9PiB7XG4gIGNvbnNvbGUuZ3JvdXAoYFtpb24tY29yZV0gUkVESVJFQ1RTWyR7cmVkaXJlY3RzLmxlbmd0aH1dYCk7XG4gIGZvciAoY29uc3QgcmVkaXJlY3Qgb2YgcmVkaXJlY3RzKSB7XG4gICAgaWYgKHJlZGlyZWN0LnRvKSB7XG4gICAgICBjb25zb2xlLmRlYnVnKCdGUk9NOiAnLCBgJGMgJHtnZW5lcmF0ZVBhdGgocmVkaXJlY3QuZnJvbSl9YCwgJ2ZvbnQtd2VpZ2h0OiBib2xkJywgJyBUTzogJywgYCRjICR7Z2VuZXJhdGVQYXRoKHJlZGlyZWN0LnRvLnNlZ21lbnRzKX1gLCAnZm9udC13ZWlnaHQ6IGJvbGQnKTtcbiAgICB9XG4gIH1cbiAgY29uc29sZS5ncm91cEVuZCgpO1xufTtcblxuLyoqXG4gKiBBY3RpdmF0ZXMgdGhlIHBhc3NlZCByb3V0ZSBjaGFpbi5cbiAqXG4gKiBUaGVyZSBtdXN0IGJlIGV4YWN0bHkgb25lIG91dGxldCBwZXIgcm91dGUgZW50cnkgaW4gdGhlIGNoYWluLlxuICpcbiAqIFRoZSBtZXRob2RzIGNhbGxzIHNldFJvdXRlSWQgb24gZWFjaCBvZiB0aGUgb3V0bGV0IHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgcm91dGUgZW50cnkgaW4gdGhlIGNoYWluLlxuICogc2V0Um91dGVJZCB3aWxsIGNyZWF0ZSBvciBzZWxlY3QgdGhlIHZpZXcgaW4gdGhlIG91dGxldC5cbiAqL1xuY29uc3Qgd3JpdGVOYXZTdGF0ZSA9IGFzeW5jIChyb290LCBjaGFpbiwgZGlyZWN0aW9uLCBpbmRleCwgY2hhbmdlZCA9IGZhbHNlLCBhbmltYXRpb24pID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBmaW5kIG5leHQgbmF2aWdhdGlvbiBvdXRsZXQgaW4gdGhlIERPTVxuICAgIGNvbnN0IG91dGxldCA9IHNlYXJjaE5hdk5vZGUocm9vdCk7XG4gICAgLy8gbWFrZSBzdXJlIHdlIGNhbiBjb250aW51ZSBpbnRlcmFjdGluZyB0aGUgRE9NLCBvdGhlcndpc2UgYWJvcnRcbiAgICBpZiAoaW5kZXggPj0gY2hhaW4ubGVuZ3RoIHx8ICFvdXRsZXQpIHtcbiAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gY29tcG9uZW50T25SZWFkeShvdXRsZXQsIHJlc29sdmUpKTtcbiAgICBjb25zdCByb3V0ZSA9IGNoYWluW2luZGV4XTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvdXRsZXQuc2V0Um91dGVJZChyb3V0ZS5pZCwgcm91dGUucGFyYW1zLCBkaXJlY3Rpb24sIGFuaW1hdGlvbik7XG4gICAgLy8gaWYgdGhlIG91dGxldCBjaGFuZ2VkIHRoZSBwYWdlLCByZXNldCBuYXZpZ2F0aW9uIHRvIG5ldXRyYWwgKG5vIGRpcmVjdGlvbilcbiAgICAvLyB0aGlzIG1lYW5zIG5lc3RlZCBvdXRsZXRzIHdpbGwgbm90IGFuaW1hdGVcbiAgICBpZiAocmVzdWx0LmNoYW5nZWQpIHtcbiAgICAgIGRpcmVjdGlvbiA9IFJPVVRFUl9JTlRFTlRfTk9ORTtcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyByZWN1cnNpdmVseSBzZXQgbmVzdGVkIG91dGxldHNcbiAgICBjaGFuZ2VkID0gYXdhaXQgd3JpdGVOYXZTdGF0ZShyZXN1bHQuZWxlbWVudCwgY2hhaW4sIGRpcmVjdGlvbiwgaW5kZXggKyAxLCBjaGFuZ2VkLCBhbmltYXRpb24pO1xuICAgIC8vIG9uY2UgYWxsIG5lc3RlZCBvdXRsZXRzIGFyZSB2aXNpYmxlIGxldCdzIG1ha2UgdGhlIHBhcmVudCB2aXNpYmxlIHRvbyxcbiAgICAvLyB1c2luZyBtYXJrVmlzaWJsZSBwcmV2ZW50cyBmbGlja2VyaW5nXG4gICAgaWYgKHJlc3VsdC5tYXJrVmlzaWJsZSkge1xuICAgICAgYXdhaXQgcmVzdWx0Lm1hcmtWaXNpYmxlKCk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHdhbGtzIHRoZSBvdXRsZXQgaW4gdGhlIERPTS5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhIGxpc3Qgb2YgUm91dGVJRCBjb3JyZXNwb25kaW5nIHRvIGVhY2ggb2YgdGhlIG91dGxldCBhbmQgdGhlIGxhc3Qgb3V0bGV0IHdpdGhvdXQgYSBSb3V0ZUlELlxuICovXG5jb25zdCByZWFkTmF2U3RhdGUgPSBhc3luYyAocm9vdCkgPT4ge1xuICBjb25zdCBpZHMgPSBbXTtcbiAgbGV0IG91dGxldDtcbiAgbGV0IG5vZGUgPSByb290O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgd2hpbGUgKChvdXRsZXQgPSBzZWFyY2hOYXZOb2RlKG5vZGUpKSkge1xuICAgIGNvbnN0IGlkID0gYXdhaXQgb3V0bGV0LmdldFJvdXRlSWQoKTtcbiAgICBpZiAoaWQpIHtcbiAgICAgIG5vZGUgPSBpZC5lbGVtZW50O1xuICAgICAgaWQuZWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgIGlkcy5wdXNoKGlkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgaWRzLCBvdXRsZXQgfTtcbn07XG5jb25zdCB3YWl0VW50aWxOYXZOb2RlID0gKCkgPT4ge1xuICBpZiAoc2VhcmNoTmF2Tm9kZShkb2N1bWVudC5ib2R5KSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaW9uTmF2V2lsbExvYWQnLCAoKSA9PiByZXNvbHZlKCksIHsgb25jZTogdHJ1ZSB9KTtcbiAgfSk7XG59O1xuLyoqIFNlbGVjdG9yIGZvciBhbGwgdGhlIG91dGxldHMgc3VwcG9ydGVkIGJ5IHRoZSByb3V0ZXIuICovXG5jb25zdCBPVVRMRVRfU0VMRUNUT1IgPSAnOm5vdChbbm8tcm91dGVyXSkgaW9uLW5hdiwgOm5vdChbbm8tcm91dGVyXSkgaW9uLXRhYnMsIDpub3QoW25vLXJvdXRlcl0pIGlvbi1yb3V0ZXItb3V0bGV0JztcbmNvbnN0IHNlYXJjaE5hdk5vZGUgPSAocm9vdCkgPT4ge1xuICBpZiAoIXJvb3QpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChyb290Lm1hdGNoZXMoT1VUTEVUX1NFTEVDVE9SKSkge1xuICAgIHJldHVybiByb290O1xuICB9XG4gIGNvbnN0IG91dGxldCA9IHJvb3QucXVlcnlTZWxlY3RvcihPVVRMRVRfU0VMRUNUT1IpO1xuICByZXR1cm4gb3V0bGV0ICE9PSBudWxsICYmIG91dGxldCAhPT0gdm9pZCAwID8gb3V0bGV0IDogdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIHJlZGlyZWN0IG1hdGNoZXMgdGhlIGdpdmVuIHBhdGggc2VnbWVudHMuXG4gKlxuICogQSByZWRpcmVjdCBtYXRjaGVzIHdoZW4gdGhlIHNlZ21lbnRzIG9mIHRoZSBwYXRoIGFuZCByZWRpcmVjdC5mcm9tIGFyZSBlcXVhbC5cbiAqIE5vdGUgdGhhdCBzZWdtZW50cyBhcmUgb25seSBjaGVja2VkIHVudGlsIHJlZGlyZWN0LmZyb20gY29udGFpbnMgYSAnKicgd2hpY2ggbWF0Y2hlcyBhbnkgcGF0aCBzZWdtZW50LlxuICogVGhlIHBhdGggWydzb21lJywgJ3BhdGgnLCAndG8nLCAncGFnZSddIG1hdGNoZXMgYm90aCBbJ3NvbWUnLCAncGF0aCcsICd0bycsICdwYWdlJ10gYW5kIFsnc29tZScsICdwYXRoJywgJyonXS5cbiAqL1xuY29uc3QgbWF0Y2hlc1JlZGlyZWN0ID0gKHNlZ21lbnRzLCByZWRpcmVjdCkgPT4ge1xuICBjb25zdCB7IGZyb20sIHRvIH0gPSByZWRpcmVjdDtcbiAgaWYgKHRvID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZyb20ubGVuZ3RoID4gc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZnJvbS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGV4cGVjdGVkID0gZnJvbVtpXTtcbiAgICBpZiAoZXhwZWN0ZWQgPT09ICcqJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChleHBlY3RlZCAhPT0gc2VnbWVudHNbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyb20ubGVuZ3RoID09PSBzZWdtZW50cy5sZW5ndGg7XG59O1xuLyoqIFJldHVybnMgdGhlIGZpcnN0IHJlZGlyZWN0IG1hdGNoaW5nIHRoZSBwYXRoIHNlZ21lbnRzIG9yIHVuZGVmaW5lZCB3aGVuIG5vIG1hdGNoIGZvdW5kLiAqL1xuY29uc3QgZmluZFJvdXRlUmVkaXJlY3QgPSAoc2VnbWVudHMsIHJlZGlyZWN0cykgPT4ge1xuICByZXR1cm4gcmVkaXJlY3RzLmZpbmQoKHJlZGlyZWN0KSA9PiBtYXRjaGVzUmVkaXJlY3Qoc2VnbWVudHMsIHJlZGlyZWN0KSk7XG59O1xuY29uc3QgbWF0Y2hlc0lEcyA9IChpZHMsIGNoYWluKSA9PiB7XG4gIGNvbnN0IGxlbiA9IE1hdGgubWluKGlkcy5sZW5ndGgsIGNoYWluLmxlbmd0aCk7XG4gIGxldCBzY29yZSA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCByb3V0ZUlkID0gaWRzW2ldO1xuICAgIGNvbnN0IHJvdXRlQ2hhaW4gPSBjaGFpbltpXTtcbiAgICAvLyBTa2lwIHJlc3VsdHMgd2hlcmUgdGhlIHJvdXRlIGlkIGRvZXMgbm90IG1hdGNoIHRoZSBjaGFpbiBhdCB0aGUgc2FtZSBpbmRleFxuICAgIGlmIChyb3V0ZUlkLmlkLnRvTG93ZXJDYXNlKCkgIT09IHJvdXRlQ2hhaW4uaWQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAocm91dGVJZC5wYXJhbXMpIHtcbiAgICAgIGNvbnN0IHJvdXRlSWRQYXJhbXMgPSBPYmplY3Qua2V5cyhyb3V0ZUlkLnBhcmFtcyk7XG4gICAgICAvLyBPbmx5IGNvbXBhcmUgcm91dGVzIHdpdGggdGhlIGNoYWluIHRoYXQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgcGFyYW1ldGVycy5cbiAgICAgIGlmIChyb3V0ZUlkUGFyYW1zLmxlbmd0aCA9PT0gcm91dGVDaGFpbi5zZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gTWFwcyB0aGUgcm91dGUncyBwYXJhbXMgaW50byBhIHBhdGggYmFzZWQgb24gdGhlIHBhdGggdmFyaWFibGUgbmFtZXMsXG4gICAgICAgIC8vIHRvIGNvbXBhcmUgYWdhaW5zdCB0aGUgcm91dGUgY2hhaW4gZm9ybWF0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBCZWZvcmU6XG4gICAgICAgIC8vIGBgYHRzXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gIHBhcmFtczoge1xuICAgICAgICAvLyAgICBzMTogJ2EnLFxuICAgICAgICAvLyAgICBzMjogJ2InXG4gICAgICAgIC8vICB9XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gYGBgXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFmdGVyOlxuICAgICAgICAvLyBgYGB0c1xuICAgICAgICAvLyBbJzpzMScsJzpzMiddXG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvL1xuICAgICAgICBjb25zdCBwYXRoV2l0aFBhcmFtcyA9IHJvdXRlSWRQYXJhbXMubWFwKChrZXkpID0+IGA6JHtrZXl9YCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGF0aFdpdGhQYXJhbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAvLyBTa2lwIHJlc3VsdHMgd2hlcmUgdGhlIHBhdGggdmFyaWFibGUgaXMgbm90IGEgbWF0Y2hcbiAgICAgICAgICBpZiAocGF0aFdpdGhQYXJhbXNbal0udG9Mb3dlckNhc2UoKSAhPT0gcm91dGVDaGFpbi5zZWdtZW50c1tqXSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFdlaWdodCBwYXRoIG1hdGNoZXMgZm9yIHRoZSBzYW1lIGluZGV4IGhpZ2hlci5cbiAgICAgICAgICBzY29yZSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFdlaWdodCBpZCBtYXRjaGVzXG4gICAgc2NvcmUrKztcbiAgfVxuICByZXR1cm4gc2NvcmU7XG59O1xuLyoqXG4gKiBNYXRjaGVzIHRoZSBzZWdtZW50cyBhZ2FpbnN0IHRoZSBjaGFpbi5cbiAqXG4gKiBSZXR1cm5zOlxuICogLSBudWxsIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2gsXG4gKiAtIGEgY2hhaW4gd2l0aCB0aGUgcGFyYW1zIHByb3BlcnRpZXMgdXBkYXRlZCB3aXRoIHRoZSBwYXJhbWV0ZXIgc2VnbWVudHMgb24gbWF0Y2guXG4gKi9cbmNvbnN0IG1hdGNoZXNTZWdtZW50cyA9IChzZWdtZW50cywgY2hhaW4pID0+IHtcbiAgY29uc3QgaW5wdXRTZWdtZW50cyA9IG5ldyBSb3V0ZXJTZWdtZW50cyhzZWdtZW50cyk7XG4gIGxldCBtYXRjaGVzRGVmYXVsdCA9IGZhbHNlO1xuICBsZXQgYWxscGFyYW1zO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYWluLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhaW5TZWdtZW50cyA9IGNoYWluW2ldLnNlZ21lbnRzO1xuICAgIGlmIChjaGFpblNlZ21lbnRzWzBdID09PSAnJykge1xuICAgICAgbWF0Y2hlc0RlZmF1bHQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBjaGFpblNlZ21lbnRzKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBpbnB1dFNlZ21lbnRzLm5leHQoKTtcbiAgICAgICAgLy8gZGF0YSBwYXJhbVxuICAgICAgICBpZiAoc2VnbWVudFswXSA9PT0gJzonKSB7XG4gICAgICAgICAgaWYgKGRhdGEgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWxscGFyYW1zID0gYWxscGFyYW1zIHx8IFtdO1xuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGFsbHBhcmFtc1tpXSB8fCAoYWxscGFyYW1zW2ldID0ge30pO1xuICAgICAgICAgIHBhcmFtc1tzZWdtZW50LnNsaWNlKDEpXSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YSAhPT0gc2VnbWVudCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYXRjaGVzRGVmYXVsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBjb25zdCBtYXRjaGVzID0gbWF0Y2hlc0RlZmF1bHQgPyBtYXRjaGVzRGVmYXVsdCA9PT0gKGlucHV0U2VnbWVudHMubmV4dCgpID09PSAnJykgOiB0cnVlO1xuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoYWxscGFyYW1zKSB7XG4gICAgcmV0dXJuIGNoYWluLm1hcCgocm91dGUsIGkpID0+ICh7XG4gICAgICBpZDogcm91dGUuaWQsXG4gICAgICBzZWdtZW50czogcm91dGUuc2VnbWVudHMsXG4gICAgICBwYXJhbXM6IG1lcmdlUGFyYW1zKHJvdXRlLnBhcmFtcywgYWxscGFyYW1zW2ldKSxcbiAgICAgIGJlZm9yZUVudGVyOiByb3V0ZS5iZWZvcmVFbnRlcixcbiAgICAgIGJlZm9yZUxlYXZlOiByb3V0ZS5iZWZvcmVMZWF2ZSxcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIGNoYWluO1xufTtcbi8qKlxuICogTWVyZ2VzIHRoZSByb3V0ZSBwYXJhbWV0ZXIgb2JqZWN0cy5cbiAqIFJldHVybnMgdW5kZWZpbmVkIHdoZW4gYm90aCBwYXJhbWV0ZXJzIGFyZSB1bmRlZmluZWQuXG4gKi9cbmNvbnN0IG1lcmdlUGFyYW1zID0gKGEsIGIpID0+IHtcbiAgcmV0dXJuIGEgfHwgYiA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYSksIGIpIDogdW5kZWZpbmVkO1xufTtcbi8qKlxuICogRmluZHMgdGhlIGJlc3QgbWF0Y2ggZm9yIHRoZSBpZHMgaW4gdGhlIGNoYWlucy5cbiAqXG4gKiBSZXR1cm5zIHRoZSBiZXN0IG1hdGNoIG9yIG51bGwgd2hlbiBubyBtYXRjaCBpcyBmb3VuZC5cbiAqIFdoZW4gYSBjaGFpbiBpcyByZXR1cm5lZCB0aGUgcGFyYW1ldGVycyBhcmUgdXBkYXRlZCBmcm9tIHRoZSBSb3V0ZUlEcy5cbiAqIFRoYXQgaXMgdGhleSBjb250YWluIGJvdGggdGhlIGNvbXBvbmVudFByb3BzIG9mIHRoZSA8aW9uLXJvdXRlPiBhbmQgdGhlIHBhcmFtZXRlciBzZWdtZW50LlxuICovXG5jb25zdCBmaW5kQ2hhaW5Gb3JJRHMgPSAoaWRzLCBjaGFpbnMpID0+IHtcbiAgbGV0IG1hdGNoID0gbnVsbDtcbiAgbGV0IG1heE1hdGNoZXMgPSAwO1xuICBmb3IgKGNvbnN0IGNoYWluIG9mIGNoYWlucykge1xuICAgIGNvbnN0IHNjb3JlID0gbWF0Y2hlc0lEcyhpZHMsIGNoYWluKTtcbiAgICBpZiAoc2NvcmUgPiBtYXhNYXRjaGVzKSB7XG4gICAgICBtYXRjaCA9IGNoYWluO1xuICAgICAgbWF4TWF0Y2hlcyA9IHNjb3JlO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4gbWF0Y2gubWFwKChyb3V0ZSwgaSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuICh7XG4gICAgICAgIGlkOiByb3V0ZS5pZCxcbiAgICAgICAgc2VnbWVudHM6IHJvdXRlLnNlZ21lbnRzLFxuICAgICAgICBwYXJhbXM6IG1lcmdlUGFyYW1zKHJvdXRlLnBhcmFtcywgKF9hID0gaWRzW2ldKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyYW1zKSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbi8qKlxuICogRmluZHMgdGhlIGJlc3QgbWF0Y2ggZm9yIHRoZSBzZWdtZW50cyBpbiB0aGUgY2hhaW5zLlxuICpcbiAqIFJldHVybnMgdGhlIGJlc3QgbWF0Y2ggb3IgbnVsbCB3aGVuIG5vIG1hdGNoIGlzIGZvdW5kLlxuICogV2hlbiBhIGNoYWluIGlzIHJldHVybmVkIHRoZSBwYXJhbWV0ZXJzIGFyZSB1cGRhdGVkIGZyb20gdGhlIHNlZ21lbnRzLlxuICogVGhhdCBpcyB0aGV5IGNvbnRhaW4gYm90aCB0aGUgY29tcG9uZW50UHJvcHMgb2YgdGhlIDxpb24tcm91dGU+IGFuZCB0aGUgcGFyYW1ldGVyIHNlZ21lbnRzLlxuICovXG5jb25zdCBmaW5kQ2hhaW5Gb3JTZWdtZW50cyA9IChzZWdtZW50cywgY2hhaW5zKSA9PiB7XG4gIGxldCBtYXRjaCA9IG51bGw7XG4gIGxldCBiZXN0U2NvcmUgPSAwO1xuICBmb3IgKGNvbnN0IGNoYWluIG9mIGNoYWlucykge1xuICAgIGNvbnN0IG1hdGNoZWRDaGFpbiA9IG1hdGNoZXNTZWdtZW50cyhzZWdtZW50cywgY2hhaW4pO1xuICAgIGlmIChtYXRjaGVkQ2hhaW4gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHNjb3JlID0gY29tcHV0ZVByaW9yaXR5KG1hdGNoZWRDaGFpbik7XG4gICAgICBpZiAoc2NvcmUgPiBiZXN0U2NvcmUpIHtcbiAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XG4gICAgICAgIG1hdGNoID0gbWF0Y2hlZENoYWluO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWF0Y2g7XG59O1xuLyoqXG4gKiBDb21wdXRlcyB0aGUgcHJpb3JpdHkgb2YgYSBjaGFpbi5cbiAqXG4gKiBQYXJhbWV0ZXIgc2VnbWVudHMgYXJlIGdpdmVuIGEgbG93ZXIgcHJpb3JpdHkgb3ZlciBmaXhlZCBzZWdtZW50cy5cbiAqXG4gKiBDb25zaWRlcmluZyB0aGUgZm9sbG93aW5nIDIgY2hhaW5zIG1hdGNoaW5nIHRoZSBwYXRoIC9wYXRoL3RvL3BhZ2U6XG4gKiAtIC9wYXRoL3RvLzp3aGVyZVxuICogLSAvcGF0aC90by9wYWdlXG4gKlxuICogVGhlIHNlY29uZCBvbmUgd2lsbCBiZSBnaXZlbiBhIGhpZ2hlciBwcmlvcml0eSBiZWNhdXNlIFwicGFnZVwiIGlzIGEgZml4ZWQgc2VnbWVudCAodnMgXCI6d2hlcmVcIiwgYSBwYXJhbWV0ZXIgc2VnbWVudCkuXG4gKi9cbmNvbnN0IGNvbXB1dGVQcmlvcml0eSA9IChjaGFpbikgPT4ge1xuICBsZXQgc2NvcmUgPSAxO1xuICBsZXQgbGV2ZWwgPSAxO1xuICBmb3IgKGNvbnN0IHJvdXRlIG9mIGNoYWluKSB7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHJvdXRlLnNlZ21lbnRzKSB7XG4gICAgICBpZiAoc2VnbWVudFswXSA9PT0gJzonKSB7XG4gICAgICAgIHNjb3JlICs9IE1hdGgucG93KDEsIGxldmVsKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlZ21lbnQgIT09ICcnKSB7XG4gICAgICAgIHNjb3JlICs9IE1hdGgucG93KDIsIGxldmVsKTtcbiAgICAgIH1cbiAgICAgIGxldmVsKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBzY29yZTtcbn07XG5jbGFzcyBSb3V0ZXJTZWdtZW50cyB7XG4gIGNvbnN0cnVjdG9yKHNlZ21lbnRzKSB7XG4gICAgdGhpcy5zZWdtZW50cyA9IHNlZ21lbnRzLnNsaWNlKCk7XG4gIH1cbiAgbmV4dCgpIHtcbiAgICBpZiAodGhpcy5zZWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWdtZW50cy5zaGlmdCgpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuY29uc3QgcmVhZFByb3AgPSAoZWwsIHByb3ApID0+IHtcbiAgaWYgKHByb3AgaW4gZWwpIHtcbiAgICByZXR1cm4gZWxbcHJvcF07XG4gIH1cbiAgaWYgKGVsLmhhc0F0dHJpYnV0ZShwcm9wKSkge1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUocHJvcCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBFeHRyYWN0cyB0aGUgcmVkaXJlY3RzICh0aGF0IGlzIDxpb24tcm91dGUtcmVkaXJlY3Q+IGVsZW1lbnRzIGluc2lkZSB0aGUgcm9vdCkuXG4gKlxuICogVGhlIHJlZGlyZWN0cyBhcmUgcmV0dXJuZWQgYXMgYSBsaXN0IG9mIFJvdXRlUmVkaXJlY3QuXG4gKi9cbmNvbnN0IHJlYWRSZWRpcmVjdHMgPSAocm9vdCkgPT4ge1xuICByZXR1cm4gQXJyYXkuZnJvbShyb290LmNoaWxkcmVuKVxuICAgIC5maWx0ZXIoKGVsKSA9PiBlbC50YWdOYW1lID09PSAnSU9OLVJPVVRFLVJFRElSRUNUJylcbiAgICAubWFwKChlbCkgPT4ge1xuICAgIGNvbnN0IHRvID0gcmVhZFByb3AoZWwsICd0bycpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tOiBwYXJzZVBhdGgocmVhZFByb3AoZWwsICdmcm9tJykpLnNlZ21lbnRzLFxuICAgICAgdG86IHRvID09IG51bGwgPyB1bmRlZmluZWQgOiBwYXJzZVBhdGgodG8pLFxuICAgIH07XG4gIH0pO1xufTtcbi8qKlxuICogRXh0cmFjdHMgYWxsIHRoZSByb3V0ZXMgKHRoYXQgaXMgPGlvbi1yb3V0ZT4gZWxlbWVudHMgaW5zaWRlIHRoZSByb290KS5cbiAqXG4gKiBUaGUgcm91dGVzIGFyZSByZXR1cm5lZCBhcyBhIGxpc3Qgb2YgY2hhaW5zIC0gdGhlIGZsYXR0ZW5lZCB0cmVlLlxuICovXG5jb25zdCByZWFkUm91dGVzID0gKHJvb3QpID0+IHtcbiAgcmV0dXJuIGZsYXR0ZW5Sb3V0ZXJUcmVlKHJlYWRSb3V0ZU5vZGVzKHJvb3QpKTtcbn07XG4vKipcbiAqIFJlYWRzIHRoZSByb3V0ZSBub2RlcyBhcyBhIHRyZWUgbW9kZWxlZCBhZnRlciB0aGUgRE9NIHRyZWUgb2YgPGlvbi1yb3V0ZT4gZWxlbWVudHMuXG4gKlxuICogTm90ZTogcm91dGVzIHdpdGhvdXQgYSBjb21wb25lbnQgYXJlIGlnbm9yZWQgdG9nZXRoZXIgd2l0aCB0aGVpciBjaGlsZHJlbi5cbiAqL1xuY29uc3QgcmVhZFJvdXRlTm9kZXMgPSAobm9kZSkgPT4ge1xuICByZXR1cm4gQXJyYXkuZnJvbShub2RlLmNoaWxkcmVuKVxuICAgIC5maWx0ZXIoKGVsKSA9PiBlbC50YWdOYW1lID09PSAnSU9OLVJPVVRFJyAmJiBlbC5jb21wb25lbnQpXG4gICAgLm1hcCgoZWwpID0+IHtcbiAgICBjb25zdCBjb21wb25lbnQgPSByZWFkUHJvcChlbCwgJ2NvbXBvbmVudCcpO1xuICAgIHJldHVybiB7XG4gICAgICBzZWdtZW50czogcGFyc2VQYXRoKHJlYWRQcm9wKGVsLCAndXJsJykpLnNlZ21lbnRzLFxuICAgICAgaWQ6IGNvbXBvbmVudC50b0xvd2VyQ2FzZSgpLFxuICAgICAgcGFyYW1zOiBlbC5jb21wb25lbnRQcm9wcyxcbiAgICAgIGJlZm9yZUxlYXZlOiBlbC5iZWZvcmVMZWF2ZSxcbiAgICAgIGJlZm9yZUVudGVyOiBlbC5iZWZvcmVFbnRlcixcbiAgICAgIGNoaWxkcmVuOiByZWFkUm91dGVOb2RlcyhlbCksXG4gICAgfTtcbiAgfSk7XG59O1xuLyoqXG4gKiBGbGF0dGVucyBhIFJvdXRlclRyZWUgaW4gYSBsaXN0IG9mIGNoYWlucy5cbiAqXG4gKiBFYWNoIGNoYWluIHJlcHJlc2VudHMgYSBwYXRoIGZyb20gdGhlIHJvb3Qgbm9kZSB0byBhIHRlcm1pbmFsIG5vZGUuXG4gKi9cbmNvbnN0IGZsYXR0ZW5Sb3V0ZXJUcmVlID0gKG5vZGVzKSA9PiB7XG4gIGNvbnN0IGNoYWlucyA9IFtdO1xuICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICBmbGF0dGVuTm9kZShbXSwgY2hhaW5zLCBub2RlKTtcbiAgfVxuICByZXR1cm4gY2hhaW5zO1xufTtcbi8qKiBGbGF0dGVucyBhIHJvdXRlIG5vZGUgcmVjdXJzaXZlbHkgYW5kIHB1c2ggZWFjaCBicmFuY2ggdG8gdGhlIGNoYWlucyBsaXN0LiAqL1xuY29uc3QgZmxhdHRlbk5vZGUgPSAoY2hhaW4sIGNoYWlucywgbm9kZSkgPT4ge1xuICBjaGFpbiA9IFtcbiAgICAuLi5jaGFpbixcbiAgICB7XG4gICAgICBpZDogbm9kZS5pZCxcbiAgICAgIHNlZ21lbnRzOiBub2RlLnNlZ21lbnRzLFxuICAgICAgcGFyYW1zOiBub2RlLnBhcmFtcyxcbiAgICAgIGJlZm9yZUxlYXZlOiBub2RlLmJlZm9yZUxlYXZlLFxuICAgICAgYmVmb3JlRW50ZXI6IG5vZGUuYmVmb3JlRW50ZXIsXG4gICAgfSxcbiAgXTtcbiAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgY2hhaW5zLnB1c2goY2hhaW4pO1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICBmbGF0dGVuTm9kZShjaGFpbiwgY2hhaW5zLCBjaGlsZCk7XG4gIH1cbn07XG5cbmNvbnN0IFJvdXRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgdGhpcy5pb25Sb3V0ZVdpbGxDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImlvblJvdXRlV2lsbENoYW5nZVwiLCA3KTtcbiAgICB0aGlzLmlvblJvdXRlRGlkQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJpb25Sb3V0ZURpZENoYW5nZVwiLCA3KTtcbiAgICB0aGlzLnByZXZpb3VzUGF0aCA9IG51bGw7XG4gICAgdGhpcy5idXN5ID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZSA9IDA7XG4gICAgdGhpcy5sYXN0U3RhdGUgPSAwO1xuICAgIC8qKlxuICAgICAqIFRoZSByb290IHBhdGggdG8gdXNlIHdoZW4gbWF0Y2hpbmcgVVJMcy4gQnkgZGVmYXVsdCwgdGhpcyBpcyBzZXQgdG8gXCIvXCIsIGJ1dCB5b3UgY2FuIHNwZWNpZnlcbiAgICAgKiBhbiBhbHRlcm5hdGUgcHJlZml4IGZvciBhbGwgVVJMIHBhdGhzLlxuICAgICAqL1xuICAgIHRoaXMucm9vdCA9ICcvJztcbiAgICAvKipcbiAgICAgKiBUaGUgcm91dGVyIGNhbiB3b3JrIGluIHR3byBcIm1vZGVzXCI6XG4gICAgICogLSBXaXRoIGhhc2g6IGAvaW5kZXguaHRtbCMvcGF0aC90by9wYWdlYFxuICAgICAqIC0gV2l0aG91dCBoYXNoOiBgL3BhdGgvdG8vcGFnZWBcbiAgICAgKlxuICAgICAqIFVzaW5nIG9uZSBvciBhbm90aGVyIG1pZ2h0IGRlcGVuZCBpbiB0aGUgcmVxdWlyZW1lbnRzIG9mIHlvdXIgYXBwIGFuZC9vciB3aGVyZSBpdCdzIGRlcGxveWVkLlxuICAgICAqXG4gICAgICogVXN1YWxseSBcImhhc2gtbGVzc1wiIG5hdmlnYXRpb24gd29ya3MgYmV0dGVyIGZvciBTRU8gYW5kIGl0J3MgbW9yZSB1c2VyIGZyaWVuZGx5IHRvbywgYnV0IGl0IG1pZ2h0XG4gICAgICogcmVxdWlyZXMgYWRkaXRpb25hbCBzZXJ2ZXItc2lkZSBjb25maWd1cmF0aW9uIGluIG9yZGVyIHRvIHByb3Blcmx5IHdvcmsuXG4gICAgICpcbiAgICAgKiBPbiB0aGUgb3RoZXIgc2lkZSBoYXNoLW5hdmlnYXRpb24gaXMgbXVjaCBlYXNpZXIgdG8gZGVwbG95LCBpdCBldmVuIHdvcmtzIG92ZXIgdGhlIGZpbGUgcHJvdG9jb2wuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGlzIHByb3BlcnR5IGlzIGB0cnVlYCwgY2hhbmdlIHRvIGBmYWxzZWAgdG8gYWxsb3cgaGFzaC1sZXNzIFVSTHMuXG4gICAgICovXG4gICAgdGhpcy51c2VIYXNoID0gdHJ1ZTtcbiAgfVxuICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICBhd2FpdCB3YWl0VW50aWxOYXZOb2RlKCk7XG4gICAgY29uc3QgY2FuUHJvY2VlZCA9IGF3YWl0IHRoaXMucnVuR3VhcmRzKHRoaXMuZ2V0U2VnbWVudHMoKSk7XG4gICAgaWYgKGNhblByb2NlZWQgIT09IHRydWUpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FuUHJvY2VlZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgeyByZWRpcmVjdCB9ID0gY2FuUHJvY2VlZDtcbiAgICAgICAgY29uc3QgcGF0aCA9IHBhcnNlUGF0aChyZWRpcmVjdCk7XG4gICAgICAgIHRoaXMuc2V0U2VnbWVudHMocGF0aC5zZWdtZW50cywgUk9VVEVSX0lOVEVOVF9OT05FLCBwYXRoLnF1ZXJ5U3RyaW5nKTtcbiAgICAgICAgYXdhaXQgdGhpcy53cml0ZU5hdlN0YXRlUm9vdChwYXRoLnNlZ21lbnRzLCBST1VURVJfSU5URU5UX05PTkUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGF3YWl0IHRoaXMub25Sb3V0ZXNDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2lvblJvdXRlUmVkaXJlY3RDaGFuZ2VkJywgZGVib3VuY2UodGhpcy5vblJlZGlyZWN0Q2hhbmdlZC5iaW5kKHRoaXMpLCAxMCkpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdpb25Sb3V0ZURhdGFDaGFuZ2VkJywgZGVib3VuY2UodGhpcy5vblJvdXRlc0NoYW5nZWQuYmluZCh0aGlzKSwgMTAwKSk7XG4gIH1cbiAgYXN5bmMgb25Qb3BTdGF0ZSgpIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmhpc3RvcnlEaXJlY3Rpb24oKTtcbiAgICBsZXQgc2VnbWVudHMgPSB0aGlzLmdldFNlZ21lbnRzKCk7XG4gICAgY29uc3QgY2FuUHJvY2VlZCA9IGF3YWl0IHRoaXMucnVuR3VhcmRzKHNlZ21lbnRzKTtcbiAgICBpZiAoY2FuUHJvY2VlZCAhPT0gdHJ1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBjYW5Qcm9jZWVkID09PSAnb2JqZWN0Jykge1xuICAgICAgICBzZWdtZW50cyA9IHBhcnNlUGF0aChjYW5Qcm9jZWVkLnJlZGlyZWN0KS5zZWdtZW50cztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndyaXRlTmF2U3RhdGVSb290KHNlZ21lbnRzLCBkaXJlY3Rpb24pO1xuICB9XG4gIG9uQmFja0J1dHRvbihldikge1xuICAgIGV2LmRldGFpbC5yZWdpc3RlcigwLCAocHJvY2Vzc05leHRIYW5kbGVyKSA9PiB7XG4gICAgICB0aGlzLmJhY2soKTtcbiAgICAgIHByb2Nlc3NOZXh0SGFuZGxlcigpO1xuICAgIH0pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgY2FuVHJhbnNpdGlvbigpIHtcbiAgICBjb25zdCBjYW5Qcm9jZWVkID0gYXdhaXQgdGhpcy5ydW5HdWFyZHMoKTtcbiAgICBpZiAoY2FuUHJvY2VlZCAhPT0gdHJ1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBjYW5Qcm9jZWVkID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gY2FuUHJvY2VlZC5yZWRpcmVjdDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBOYXZpZ2F0ZSB0byB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIG5hdmlnYXRlIHRvLlxuICAgKiBAcGFyYW0gZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi4gRGVmYXVsdHMgdG8gYFwiZm9yd2FyZFwiYC5cbiAgICovXG4gIGFzeW5jIHB1c2gocGF0aCwgZGlyZWN0aW9uID0gJ2ZvcndhcmQnLCBhbmltYXRpb24pIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnLicpKSB7XG4gICAgICBjb25zdCBjdXJyZW50UGF0aCA9IChfYSA9IHRoaXMucHJldmlvdXNQYXRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnLyc7XG4gICAgICAvLyBDb252ZXJ0IGN1cnJlbnRQYXRoIHRvIGFuIFVSTCBieSBwcmUtcGVuZGluZyBhIHByb3RvY29sIGFuZCBhIGhvc3QgdG8gcmVzb2x2ZSB0aGUgcmVsYXRpdmUgcGF0aC5cbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocGF0aCwgYGh0dHBzOi8vaG9zdC8ke2N1cnJlbnRQYXRofWApO1xuICAgICAgcGF0aCA9IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2g7XG4gICAgfVxuICAgIGxldCBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKHBhdGgpO1xuICAgIGNvbnN0IGNhblByb2NlZWQgPSBhd2FpdCB0aGlzLnJ1bkd1YXJkcyhwYXJzZWRQYXRoLnNlZ21lbnRzKTtcbiAgICBpZiAoY2FuUHJvY2VlZCAhPT0gdHJ1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBjYW5Qcm9jZWVkID09PSAnb2JqZWN0Jykge1xuICAgICAgICBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKGNhblByb2NlZWQucmVkaXJlY3QpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZXRTZWdtZW50cyhwYXJzZWRQYXRoLnNlZ21lbnRzLCBkaXJlY3Rpb24sIHBhcnNlZFBhdGgucXVlcnlTdHJpbmcpO1xuICAgIHJldHVybiB0aGlzLndyaXRlTmF2U3RhdGVSb290KHBhcnNlZFBhdGguc2VnbWVudHMsIGRpcmVjdGlvbiwgYW5pbWF0aW9uKTtcbiAgfVxuICAvKiogR28gYmFjayB0byBwcmV2aW91cyBwYWdlIGluIHRoZSB3aW5kb3cuaGlzdG9yeS4gKi9cbiAgYmFjaygpIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLndhaXRQcm9taXNlKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzeW5jIHByaW50RGVidWcoKSB7XG4gICAgcHJpbnRSb3V0ZXMocmVhZFJvdXRlcyh0aGlzLmVsKSk7XG4gICAgcHJpbnRSZWRpcmVjdHMocmVhZFJlZGlyZWN0cyh0aGlzLmVsKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc3luYyBuYXZDaGFuZ2VkKGRpcmVjdGlvbikge1xuICAgIGlmICh0aGlzLmJ1c3kpIHtcbiAgICAgIGNvbnNvbGUud2FybignW2lvbi1yb3V0ZXJdIHJvdXRlciBpcyBidXN5LCBuYXZDaGFuZ2VkIHdhcyBjYW5jZWxsZWQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBpZHMsIG91dGxldCB9ID0gYXdhaXQgcmVhZE5hdlN0YXRlKHdpbmRvdy5kb2N1bWVudC5ib2R5KTtcbiAgICBjb25zdCByb3V0ZXMgPSByZWFkUm91dGVzKHRoaXMuZWwpO1xuICAgIGNvbnN0IGNoYWluID0gZmluZENoYWluRm9ySURzKGlkcywgcm91dGVzKTtcbiAgICBpZiAoIWNoYWluKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tpb24tcm91dGVyXSBubyBtYXRjaGluZyBVUkwgZm9yICcsIGlkcy5tYXAoKGkpID0+IGkuaWQpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc2VnbWVudHMgPSBjaGFpblRvU2VnbWVudHMoY2hhaW4pO1xuICAgIGlmICghc2VnbWVudHMpIHtcbiAgICAgIGNvbnNvbGUud2FybignW2lvbi1yb3V0ZXJdIHJvdXRlciBjb3VsZCBub3QgbWF0Y2ggcGF0aCBiZWNhdXNlIHNvbWUgcmVxdWlyZWQgcGFyYW0gaXMgbWlzc2luZycpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnNldFNlZ21lbnRzKHNlZ21lbnRzLCBkaXJlY3Rpb24pO1xuICAgIGF3YWl0IHRoaXMuc2FmZVdyaXRlTmF2U3RhdGUob3V0bGV0LCBjaGFpbiwgUk9VVEVSX0lOVEVOVF9OT05FLCBzZWdtZW50cywgbnVsbCwgaWRzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqIFRoaXMgaGFuZGxlciBnZXRzIGNhbGxlZCB3aGVuIGEgYGlvbi1yb3V0ZS1yZWRpcmVjdGAgY29tcG9uZW50IGlzIGFkZGVkIHRvIHRoZSBET00gb3IgaWYgdGhlIGZyb20gb3IgdG8gcHJvcGVydHkgb2Ygc3VjaCBub2RlIGNoYW5nZXMuICovXG4gIG9uUmVkaXJlY3RDaGFuZ2VkKCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5nZXRTZWdtZW50cygpO1xuICAgIGlmIChzZWdtZW50cyAmJiBmaW5kUm91dGVSZWRpcmVjdChzZWdtZW50cywgcmVhZFJlZGlyZWN0cyh0aGlzLmVsKSkpIHtcbiAgICAgIHRoaXMud3JpdGVOYXZTdGF0ZVJvb3Qoc2VnbWVudHMsIFJPVVRFUl9JTlRFTlRfTk9ORSk7XG4gICAgfVxuICB9XG4gIC8qKiBUaGlzIGhhbmRsZXIgZ2V0cyBjYWxsZWQgd2hlbiBhIGBpb24tcm91dGVgIGNvbXBvbmVudCBpcyBhZGRlZCB0byB0aGUgRE9NIG9yIGlmIHRoZSBmcm9tIG9yIHRvIHByb3BlcnR5IG9mIHN1Y2ggbm9kZSBjaGFuZ2VzLiAqL1xuICBvblJvdXRlc0NoYW5nZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMud3JpdGVOYXZTdGF0ZVJvb3QodGhpcy5nZXRTZWdtZW50cygpLCBST1VURVJfSU5URU5UX05PTkUpO1xuICB9XG4gIGhpc3RvcnlEaXJlY3Rpb24oKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHdpbiA9IHdpbmRvdztcbiAgICBpZiAod2luLmhpc3Rvcnkuc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3RhdGUrKztcbiAgICAgIHdpbi5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh0aGlzLnN0YXRlLCB3aW4uZG9jdW1lbnQudGl0bGUsIChfYSA9IHdpbi5kb2N1bWVudC5sb2NhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhyZWYpO1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHdpbi5oaXN0b3J5LnN0YXRlO1xuICAgIGNvbnN0IGxhc3RTdGF0ZSA9IHRoaXMubGFzdFN0YXRlO1xuICAgIHRoaXMubGFzdFN0YXRlID0gc3RhdGU7XG4gICAgaWYgKHN0YXRlID4gbGFzdFN0YXRlIHx8IChzdGF0ZSA+PSBsYXN0U3RhdGUgJiYgbGFzdFN0YXRlID4gMCkpIHtcbiAgICAgIHJldHVybiBST1VURVJfSU5URU5UX0ZPUldBUkQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA8IGxhc3RTdGF0ZSkge1xuICAgICAgcmV0dXJuIFJPVVRFUl9JTlRFTlRfQkFDSztcbiAgICB9XG4gICAgcmV0dXJuIFJPVVRFUl9JTlRFTlRfTk9ORTtcbiAgfVxuICBhc3luYyB3cml0ZU5hdlN0YXRlUm9vdChzZWdtZW50cywgZGlyZWN0aW9uLCBhbmltYXRpb24pIHtcbiAgICBpZiAoIXNlZ21lbnRzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbaW9uLXJvdXRlcl0gVVJMIGlzIG5vdCBwYXJ0IG9mIHRoZSByb3V0aW5nIHNldCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBsb29rdXAgcmVkaXJlY3QgcnVsZVxuICAgIGNvbnN0IHJlZGlyZWN0cyA9IHJlYWRSZWRpcmVjdHModGhpcy5lbCk7XG4gICAgY29uc3QgcmVkaXJlY3QgPSBmaW5kUm91dGVSZWRpcmVjdChzZWdtZW50cywgcmVkaXJlY3RzKTtcbiAgICBsZXQgcmVkaXJlY3RGcm9tID0gbnVsbDtcbiAgICBpZiAocmVkaXJlY3QpIHtcbiAgICAgIGNvbnN0IHsgc2VnbWVudHM6IHRvU2VnbWVudHMsIHF1ZXJ5U3RyaW5nIH0gPSByZWRpcmVjdC50bztcbiAgICAgIHRoaXMuc2V0U2VnbWVudHModG9TZWdtZW50cywgZGlyZWN0aW9uLCBxdWVyeVN0cmluZyk7XG4gICAgICByZWRpcmVjdEZyb20gPSByZWRpcmVjdC5mcm9tO1xuICAgICAgc2VnbWVudHMgPSB0b1NlZ21lbnRzO1xuICAgIH1cbiAgICAvLyBsb29rdXAgcm91dGUgY2hhaW5cbiAgICBjb25zdCByb3V0ZXMgPSByZWFkUm91dGVzKHRoaXMuZWwpO1xuICAgIGNvbnN0IGNoYWluID0gZmluZENoYWluRm9yU2VnbWVudHMoc2VnbWVudHMsIHJvdXRlcyk7XG4gICAgaWYgKCFjaGFpbikge1xuICAgICAgY29uc29sZS5lcnJvcignW2lvbi1yb3V0ZXJdIHRoZSBwYXRoIGRvZXMgbm90IG1hdGNoIGFueSByb3V0ZScpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyB3cml0ZSBET00gZ2l2ZVxuICAgIHJldHVybiB0aGlzLnNhZmVXcml0ZU5hdlN0YXRlKGRvY3VtZW50LmJvZHksIGNoYWluLCBkaXJlY3Rpb24sIHNlZ21lbnRzLCByZWRpcmVjdEZyb20sIDAsIGFuaW1hdGlvbik7XG4gIH1cbiAgYXN5bmMgc2FmZVdyaXRlTmF2U3RhdGUobm9kZSwgY2hhaW4sIGRpcmVjdGlvbiwgc2VnbWVudHMsIHJlZGlyZWN0RnJvbSwgaW5kZXggPSAwLCBhbmltYXRpb24pIHtcbiAgICBjb25zdCB1bmxvY2sgPSBhd2FpdCB0aGlzLmxvY2soKTtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBjaGFuZ2VkID0gYXdhaXQgdGhpcy53cml0ZU5hdlN0YXRlKG5vZGUsIGNoYWluLCBkaXJlY3Rpb24sIHNlZ21lbnRzLCByZWRpcmVjdEZyb20sIGluZGV4LCBhbmltYXRpb24pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gICAgdW5sb2NrKCk7XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cbiAgYXN5bmMgbG9jaygpIHtcbiAgICBjb25zdCBwID0gdGhpcy53YWl0UHJvbWlzZTtcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICB0aGlzLndhaXRQcm9taXNlID0gbmV3IFByb21pc2UoKHIpID0+IChyZXNvbHZlID0gcikpO1xuICAgIGlmIChwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGF3YWl0IHA7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgYmVmb3JlTGVhdmUgaG9vayBvZiB0aGUgc291cmNlIHJvdXRlIGFuZCB0aGUgYmVmb3JlRW50ZXIgaG9vayBvZiB0aGUgdGFyZ2V0IHJvdXRlIGlmIHRoZXkgZXhpc3QuXG4gICAqXG4gICAqIFdoZW4gdGhlIGJlZm9yZUxlYXZlIGhvb2sgZG9lcyBub3QgcmV0dXJuIHRydWUgKHRvIGFsbG93IG5hdmlnYXRpbmcpIHRoZW4gdGhhdCB2YWx1ZSBpcyByZXR1cm5lZCBlYXJseSBhbmQgdGhlIGJlZm9yZUVudGVyIGlzIGV4ZWN1dGVkLlxuICAgKiBPdGhlcndpc2UgdGhlIGJlZm9yZUVudGVySG9vayBob29rIG9mIHRoZSB0YXJnZXQgcm91dGUgaXMgZXhlY3V0ZWQuXG4gICAqL1xuICBhc3luYyBydW5HdWFyZHModG8gPSB0aGlzLmdldFNlZ21lbnRzKCksIGZyb20pIHtcbiAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tID0gcGFyc2VQYXRoKHRoaXMucHJldmlvdXNQYXRoKS5zZWdtZW50cztcbiAgICB9XG4gICAgaWYgKCF0byB8fCAhZnJvbSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHJvdXRlcyA9IHJlYWRSb3V0ZXModGhpcy5lbCk7XG4gICAgY29uc3QgZnJvbUNoYWluID0gZmluZENoYWluRm9yU2VnbWVudHMoZnJvbSwgcm91dGVzKTtcbiAgICBjb25zdCBiZWZvcmVMZWF2ZUhvb2sgPSBmcm9tQ2hhaW4gJiYgZnJvbUNoYWluW2Zyb21DaGFpbi5sZW5ndGggLSAxXS5iZWZvcmVMZWF2ZTtcbiAgICBjb25zdCBjYW5MZWF2ZSA9IGJlZm9yZUxlYXZlSG9vayA/IGF3YWl0IGJlZm9yZUxlYXZlSG9vaygpIDogdHJ1ZTtcbiAgICBpZiAoY2FuTGVhdmUgPT09IGZhbHNlIHx8IHR5cGVvZiBjYW5MZWF2ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBjYW5MZWF2ZTtcbiAgICB9XG4gICAgY29uc3QgdG9DaGFpbiA9IGZpbmRDaGFpbkZvclNlZ21lbnRzKHRvLCByb3V0ZXMpO1xuICAgIGNvbnN0IGJlZm9yZUVudGVySG9vayA9IHRvQ2hhaW4gJiYgdG9DaGFpblt0b0NoYWluLmxlbmd0aCAtIDFdLmJlZm9yZUVudGVyO1xuICAgIHJldHVybiBiZWZvcmVFbnRlckhvb2sgPyBiZWZvcmVFbnRlckhvb2soKSA6IHRydWU7XG4gIH1cbiAgYXN5bmMgd3JpdGVOYXZTdGF0ZShub2RlLCBjaGFpbiwgZGlyZWN0aW9uLCBzZWdtZW50cywgcmVkaXJlY3RGcm9tLCBpbmRleCA9IDAsIGFuaW1hdGlvbikge1xuICAgIGlmICh0aGlzLmJ1c3kpIHtcbiAgICAgIGNvbnNvbGUud2FybignW2lvbi1yb3V0ZXJdIHJvdXRlciBpcyBidXN5LCB0cmFuc2l0aW9uIHdhcyBjYW5jZWxsZWQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5idXN5ID0gdHJ1ZTtcbiAgICAvLyBnZW5lcmF0ZSByb3V0ZSBldmVudCBhbmQgZW1pdCB3aWxsIGNoYW5nZVxuICAgIGNvbnN0IHJvdXRlRXZlbnQgPSB0aGlzLnJvdXRlQ2hhbmdlRXZlbnQoc2VnbWVudHMsIHJlZGlyZWN0RnJvbSk7XG4gICAgaWYgKHJvdXRlRXZlbnQpIHtcbiAgICAgIHRoaXMuaW9uUm91dGVXaWxsQ2hhbmdlLmVtaXQocm91dGVFdmVudCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZWQgPSBhd2FpdCB3cml0ZU5hdlN0YXRlKG5vZGUsIGNoYWluLCBkaXJlY3Rpb24sIGluZGV4LCBmYWxzZSwgYW5pbWF0aW9uKTtcbiAgICB0aGlzLmJ1c3kgPSBmYWxzZTtcbiAgICAvLyBlbWl0IGRpZCBjaGFuZ2VcbiAgICBpZiAocm91dGVFdmVudCkge1xuICAgICAgdGhpcy5pb25Sb3V0ZURpZENoYW5nZS5lbWl0KHJvdXRlRXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICBzZXRTZWdtZW50cyhzZWdtZW50cywgZGlyZWN0aW9uLCBxdWVyeVN0cmluZykge1xuICAgIHRoaXMuc3RhdGUrKztcbiAgICB3cml0ZVNlZ21lbnRzKHdpbmRvdy5oaXN0b3J5LCB0aGlzLnJvb3QsIHRoaXMudXNlSGFzaCwgc2VnbWVudHMsIGRpcmVjdGlvbiwgdGhpcy5zdGF0ZSwgcXVlcnlTdHJpbmcpO1xuICB9XG4gIGdldFNlZ21lbnRzKCkge1xuICAgIHJldHVybiByZWFkU2VnbWVudHMod2luZG93LmxvY2F0aW9uLCB0aGlzLnJvb3QsIHRoaXMudXNlSGFzaCk7XG4gIH1cbiAgcm91dGVDaGFuZ2VFdmVudCh0b1NlZ21lbnRzLCByZWRpcmVjdEZyb21TZWdtZW50cykge1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLnByZXZpb3VzUGF0aDtcbiAgICBjb25zdCB0byA9IGdlbmVyYXRlUGF0aCh0b1NlZ21lbnRzKTtcbiAgICB0aGlzLnByZXZpb3VzUGF0aCA9IHRvO1xuICAgIGlmICh0byA9PT0gZnJvbSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlZGlyZWN0ZWRGcm9tID0gcmVkaXJlY3RGcm9tU2VnbWVudHMgPyBnZW5lcmF0ZVBhdGgocmVkaXJlY3RGcm9tU2VnbWVudHMpIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbSxcbiAgICAgIHJlZGlyZWN0ZWRGcm9tLFxuICAgICAgdG8sXG4gICAgfTtcbiAgfVxuICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuXG5jb25zdCByb3V0ZXJMaW5rQ3NzID0gXCI6aG9zdHstLWJhY2tncm91bmQ6dHJhbnNwYXJlbnQ7LS1jb2xvcjp2YXIoLS1pb24tY29sb3ItcHJpbWFyeSwgIzM4ODBmZik7YmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kKTtjb2xvcjp2YXIoLS1jb2xvcil9Omhvc3QoLmlvbi1jb2xvcil7Y29sb3I6dmFyKC0taW9uLWNvbG9yLWJhc2UpfWF7Zm9udC1mYW1pbHk6aW5oZXJpdDtmb250LXNpemU6aW5oZXJpdDtmb250LXN0eWxlOmluaGVyaXQ7Zm9udC13ZWlnaHQ6aW5oZXJpdDtsZXR0ZXItc3BhY2luZzppbmhlcml0O3RleHQtZGVjb3JhdGlvbjppbmhlcml0O3RleHQtaW5kZW50OmluaGVyaXQ7dGV4dC1vdmVyZmxvdzppbmhlcml0O3RleHQtdHJhbnNmb3JtOmluaGVyaXQ7dGV4dC1hbGlnbjppbmhlcml0O3doaXRlLXNwYWNlOmluaGVyaXQ7Y29sb3I6aW5oZXJpdH1cIjtcblxuY29uc3QgUm91dGVyTGluayA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgLyoqXG4gICAgICogV2hlbiB1c2luZyBhIHJvdXRlciwgaXQgc3BlY2lmaWVzIHRoZSB0cmFuc2l0aW9uIGRpcmVjdGlvbiB3aGVuIG5hdmlnYXRpbmcgdG9cbiAgICAgKiBhbm90aGVyIHBhZ2UgdXNpbmcgYGhyZWZgLlxuICAgICAqL1xuICAgIHRoaXMucm91dGVyRGlyZWN0aW9uID0gJ2ZvcndhcmQnO1xuICAgIHRoaXMub25DbGljayA9IChldikgPT4ge1xuICAgICAgb3BlblVSTCh0aGlzLmhyZWYsIGV2LCB0aGlzLnJvdXRlckRpcmVjdGlvbiwgdGhpcy5yb3V0ZXJBbmltYXRpb24pO1xuICAgIH07XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IG1vZGUgPSBnZXRJb25Nb2RlKHRoaXMpO1xuICAgIGNvbnN0IGF0dHJzID0ge1xuICAgICAgaHJlZjogdGhpcy5ocmVmLFxuICAgICAgcmVsOiB0aGlzLnJlbCxcbiAgICAgIHRhcmdldDogdGhpcy50YXJnZXQsXG4gICAgfTtcbiAgICByZXR1cm4gKGgoSG9zdCwgeyBvbkNsaWNrOiB0aGlzLm9uQ2xpY2ssIGNsYXNzOiBjcmVhdGVDb2xvckNsYXNzZXModGhpcy5jb2xvciwge1xuICAgICAgICBbbW9kZV06IHRydWUsXG4gICAgICAgICdpb24tYWN0aXZhdGFibGUnOiB0cnVlLFxuICAgICAgfSkgfSwgaChcImFcIiwgT2JqZWN0LmFzc2lnbih7fSwgYXR0cnMpLCBoKFwic2xvdFwiLCBudWxsKSkpKTtcbiAgfVxufTtcblJvdXRlckxpbmsuc3R5bGUgPSByb3V0ZXJMaW5rQ3NzO1xuXG5leHBvcnQgeyBSb3V0ZSBhcyBpb25fcm91dGUsIFJvdXRlUmVkaXJlY3QgYXMgaW9uX3JvdXRlX3JlZGlyZWN0LCBSb3V0ZXIgYXMgaW9uX3JvdXRlciwgUm91dGVyTGluayBhcyBpb25fcm91dGVyX2xpbmsgfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5jb25zdCBob3N0Q29udGV4dCA9IChzZWxlY3RvciwgZWwpID0+IHtcbiAgcmV0dXJuIGVsLmNsb3Nlc3Qoc2VsZWN0b3IpICE9PSBudWxsO1xufTtcbi8qKlxuICogQ3JlYXRlIHRoZSBtb2RlIGFuZCBjb2xvciBjbGFzc2VzIGZvciB0aGUgY29tcG9uZW50IGJhc2VkIG9uIHRoZSBjbGFzc2VzIHBhc3NlZCBpblxuICovXG5jb25zdCBjcmVhdGVDb2xvckNsYXNzZXMgPSAoY29sb3IsIGNzc0NsYXNzTWFwKSA9PiB7XG4gIHJldHVybiB0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnICYmIGNvbG9yLmxlbmd0aCA+IDBcbiAgICA/IE9iamVjdC5hc3NpZ24oeyAnaW9uLWNvbG9yJzogdHJ1ZSwgW2Bpb24tY29sb3ItJHtjb2xvcn1gXTogdHJ1ZSB9LCBjc3NDbGFzc01hcCkgOiBjc3NDbGFzc01hcDtcbn07XG5jb25zdCBnZXRDbGFzc0xpc3QgPSAoY2xhc3NlcykgPT4ge1xuICBpZiAoY2xhc3NlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgYXJyYXkgPSBBcnJheS5pc0FycmF5KGNsYXNzZXMpID8gY2xhc3NlcyA6IGNsYXNzZXMuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4gYXJyYXlcbiAgICAgIC5maWx0ZXIoKGMpID0+IGMgIT0gbnVsbClcbiAgICAgIC5tYXAoKGMpID0+IGMudHJpbSgpKVxuICAgICAgLmZpbHRlcigoYykgPT4gYyAhPT0gJycpO1xuICB9XG4gIHJldHVybiBbXTtcbn07XG5jb25zdCBnZXRDbGFzc01hcCA9IChjbGFzc2VzKSA9PiB7XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBnZXRDbGFzc0xpc3QoY2xhc3NlcykuZm9yRWFjaCgoYykgPT4gKG1hcFtjXSA9IHRydWUpKTtcbiAgcmV0dXJuIG1hcDtcbn07XG5jb25zdCBTQ0hFTUUgPSAvXlthLXpdW2EtejAtOStcXC0uXSo6LztcbmNvbnN0IG9wZW5VUkwgPSBhc3luYyAodXJsLCBldiwgZGlyZWN0aW9uLCBhbmltYXRpb24pID0+IHtcbiAgaWYgKHVybCAhPSBudWxsICYmIHVybFswXSAhPT0gJyMnICYmICFTQ0hFTUUudGVzdCh1cmwpKSB7XG4gICAgY29uc3Qgcm91dGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW9uLXJvdXRlcicpO1xuICAgIGlmIChyb3V0ZXIpIHtcbiAgICAgIGlmIChldiAhPSBudWxsKSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm91dGVyLnB1c2godXJsLCBkaXJlY3Rpb24sIGFuaW1hdGlvbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZUNvbG9yQ2xhc3NlcyBhcyBjLCBnZXRDbGFzc01hcCBhcyBnLCBob3N0Q29udGV4dCBhcyBoLCBvcGVuVVJMIGFzIG8gfTtcbiJdLCJuYW1lcyI6WyJyIiwicmVnaXN0ZXJJbnN0YW5jZSIsImUiLCJjcmVhdGVFdmVudCIsImkiLCJnZXRFbGVtZW50IiwiaCIsIkgiLCJIb3N0IiwiYyIsImNvbXBvbmVudE9uUmVhZHkiLCJxIiwiZGVib3VuY2UiLCJiIiwiZ2V0SW9uTW9kZSIsIm8iLCJvcGVuVVJMIiwiY3JlYXRlQ29sb3JDbGFzc2VzIiwiUm91dGUiLCJjb25zdHJ1Y3RvciIsImhvc3RSZWYiLCJpb25Sb3V0ZURhdGFDaGFuZ2VkIiwidXJsIiwib25VcGRhdGUiLCJuZXdWYWx1ZSIsImVtaXQiLCJvbkNvbXBvbmVudFByb3BzIiwib2xkVmFsdWUiLCJrZXlzMSIsIk9iamVjdCIsImtleXMiLCJrZXlzMiIsImxlbmd0aCIsImtleSIsImNvbm5lY3RlZENhbGxiYWNrIiwid2F0Y2hlcnMiLCJSb3V0ZVJlZGlyZWN0IiwiaW9uUm91dGVSZWRpcmVjdENoYW5nZWQiLCJwcm9wRGlkQ2hhbmdlIiwiUk9VVEVSX0lOVEVOVF9OT05FIiwiUk9VVEVSX0lOVEVOVF9GT1JXQVJEIiwiUk9VVEVSX0lOVEVOVF9CQUNLIiwiZ2VuZXJhdGVQYXRoIiwic2VnbWVudHMiLCJwYXRoIiwiZmlsdGVyIiwicyIsImpvaW4iLCJnZW5lcmF0ZVVybCIsInVzZUhhc2giLCJxdWVyeVN0cmluZyIsInVuZGVmaW5lZCIsIndyaXRlU2VnbWVudHMiLCJoaXN0b3J5Iiwicm9vdCIsImRpcmVjdGlvbiIsInN0YXRlIiwicGFyc2VQYXRoIiwicHVzaFN0YXRlIiwicmVwbGFjZVN0YXRlIiwiY2hhaW5Ub1NlZ21lbnRzIiwiY2hhaW4iLCJyb3V0ZSIsInNlZ21lbnQiLCJwYXJhbSIsInBhcmFtcyIsInNsaWNlIiwicHVzaCIsInJlbW92ZVByZWZpeCIsInByZWZpeCIsInJlYWRTZWdtZW50cyIsImxvYyIsInBhdGhuYW1lIiwiaGFzaCIsInFzU3RhcnQiLCJpbmRleE9mIiwic3Vic3RyaW5nIiwic3BsaXQiLCJtYXAiLCJ0cmltIiwicHJpbnRSb3V0ZXMiLCJyb3V0ZXMiLCJjb25zb2xlIiwiZ3JvdXAiLCJmb3JFYWNoIiwiaWRzIiwiaWQiLCJkZWJ1ZyIsImdyb3VwRW5kIiwicHJpbnRSZWRpcmVjdHMiLCJyZWRpcmVjdHMiLCJyZWRpcmVjdCIsInRvIiwiZnJvbSIsIndyaXRlTmF2U3RhdGUiLCJpbmRleCIsImNoYW5nZWQiLCJhbmltYXRpb24iLCJvdXRsZXQiLCJzZWFyY2hOYXZOb2RlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZXN1bHQiLCJzZXRSb3V0ZUlkIiwiZWxlbWVudCIsIm1hcmtWaXNpYmxlIiwiZXJyb3IiLCJyZWFkTmF2U3RhdGUiLCJub2RlIiwiZ2V0Um91dGVJZCIsIndhaXRVbnRpbE5hdk5vZGUiLCJkb2N1bWVudCIsImJvZHkiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwib25jZSIsIk9VVExFVF9TRUxFQ1RPUiIsIm1hdGNoZXMiLCJxdWVyeVNlbGVjdG9yIiwibWF0Y2hlc1JlZGlyZWN0IiwiZXhwZWN0ZWQiLCJmaW5kUm91dGVSZWRpcmVjdCIsImZpbmQiLCJtYXRjaGVzSURzIiwibGVuIiwiTWF0aCIsIm1pbiIsInNjb3JlIiwicm91dGVJZCIsInJvdXRlQ2hhaW4iLCJ0b0xvd2VyQ2FzZSIsInJvdXRlSWRQYXJhbXMiLCJwYXRoV2l0aFBhcmFtcyIsImoiLCJtYXRjaGVzU2VnbWVudHMiLCJpbnB1dFNlZ21lbnRzIiwiUm91dGVyU2VnbWVudHMiLCJtYXRjaGVzRGVmYXVsdCIsImFsbHBhcmFtcyIsImNoYWluU2VnbWVudHMiLCJkYXRhIiwibmV4dCIsIm1lcmdlUGFyYW1zIiwiYmVmb3JlRW50ZXIiLCJiZWZvcmVMZWF2ZSIsImEiLCJhc3NpZ24iLCJmaW5kQ2hhaW5Gb3JJRHMiLCJjaGFpbnMiLCJtYXRjaCIsIm1heE1hdGNoZXMiLCJfYSIsImZpbmRDaGFpbkZvclNlZ21lbnRzIiwiYmVzdFNjb3JlIiwibWF0Y2hlZENoYWluIiwiY29tcHV0ZVByaW9yaXR5IiwibGV2ZWwiLCJwb3ciLCJzaGlmdCIsInJlYWRQcm9wIiwiZWwiLCJwcm9wIiwiaGFzQXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwicmVhZFJlZGlyZWN0cyIsIkFycmF5IiwiY2hpbGRyZW4iLCJ0YWdOYW1lIiwicmVhZFJvdXRlcyIsImZsYXR0ZW5Sb3V0ZXJUcmVlIiwicmVhZFJvdXRlTm9kZXMiLCJjb21wb25lbnQiLCJjb21wb25lbnRQcm9wcyIsIm5vZGVzIiwiZmxhdHRlbk5vZGUiLCJjaGlsZCIsIlJvdXRlciIsImlvblJvdXRlV2lsbENoYW5nZSIsImlvblJvdXRlRGlkQ2hhbmdlIiwicHJldmlvdXNQYXRoIiwiYnVzeSIsImxhc3RTdGF0ZSIsImNvbXBvbmVudFdpbGxMb2FkIiwiY2FuUHJvY2VlZCIsInJ1bkd1YXJkcyIsImdldFNlZ21lbnRzIiwic2V0U2VnbWVudHMiLCJ3cml0ZU5hdlN0YXRlUm9vdCIsIm9uUm91dGVzQ2hhbmdlZCIsImNvbXBvbmVudERpZExvYWQiLCJvblJlZGlyZWN0Q2hhbmdlZCIsImJpbmQiLCJvblBvcFN0YXRlIiwiaGlzdG9yeURpcmVjdGlvbiIsIm9uQmFja0J1dHRvbiIsImV2IiwiZGV0YWlsIiwicmVnaXN0ZXIiLCJwcm9jZXNzTmV4dEhhbmRsZXIiLCJiYWNrIiwiY2FuVHJhbnNpdGlvbiIsInN0YXJ0c1dpdGgiLCJjdXJyZW50UGF0aCIsIlVSTCIsInNlYXJjaCIsInBhcnNlZFBhdGgiLCJ3YWl0UHJvbWlzZSIsInByaW50RGVidWciLCJuYXZDaGFuZ2VkIiwid2FybiIsInNhZmVXcml0ZU5hdlN0YXRlIiwid2luIiwidGl0bGUiLCJsb2NhdGlvbiIsImhyZWYiLCJyZWRpcmVjdEZyb20iLCJ0b1NlZ21lbnRzIiwidW5sb2NrIiwibG9jayIsInAiLCJmcm9tQ2hhaW4iLCJiZWZvcmVMZWF2ZUhvb2siLCJjYW5MZWF2ZSIsInRvQ2hhaW4iLCJiZWZvcmVFbnRlckhvb2siLCJyb3V0ZUV2ZW50Iiwicm91dGVDaGFuZ2VFdmVudCIsInJlZGlyZWN0RnJvbVNlZ21lbnRzIiwicmVkaXJlY3RlZEZyb20iLCJyb3V0ZXJMaW5rQ3NzIiwiUm91dGVyTGluayIsInJvdXRlckRpcmVjdGlvbiIsIm9uQ2xpY2siLCJyb3V0ZXJBbmltYXRpb24iLCJyZW5kZXIiLCJtb2RlIiwiYXR0cnMiLCJyZWwiLCJ0YXJnZXQiLCJjbGFzcyIsImNvbG9yIiwic3R5bGUiLCJpb25fcm91dGUiLCJpb25fcm91dGVfcmVkaXJlY3QiLCJpb25fcm91dGVyIiwiaW9uX3JvdXRlcl9saW5rIiwiaG9zdENvbnRleHQiLCJzZWxlY3RvciIsImNsb3Nlc3QiLCJjc3NDbGFzc01hcCIsImdldENsYXNzTGlzdCIsImNsYXNzZXMiLCJhcnJheSIsImlzQXJyYXkiLCJnZXRDbGFzc01hcCIsIlNDSEVNRSIsInRlc3QiLCJyb3V0ZXIiLCJwcmV2ZW50RGVmYXVsdCIsImciXSwic291cmNlUm9vdCI6IndlYnBhY2s6Ly8vIiwieF9nb29nbGVfaWdub3JlTGlzdCI6WzAsMV19